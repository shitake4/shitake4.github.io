[{"title":"営業最終日の繰り返し予定を Google カレンダーで作りたくて、GAS でしくみ化した話","contentSnippet":"!この記事は、Google Apps Script - Qiita Advent Calendar 2025 - Qiita 23日目の記事です 1. 始めに（なぜ作ったか）勤怠の申請、領収書の提出、経費精算の締め。 こういう事務作業系の締切って、だいたい「営業最終日」に集中します。毎月同じことをやっているはずなのに、気付いたら締切当日Slack でリマインドされて思い出す下手すると翌営業日に怒られるみたいなことを、何度も繰り返していました。「これはもう意思の力でどうにかする話じゃないな」と思い、Google カレンダーに、営業最終日の予定を自動で入れるしくみを...","link":"https://zenn.dev/shitake4/articles/ff946af2e88ae6","isoDate":"2025-12-22T23:00:02.000Z","dateMiliSeconds":1766444402000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"レガシーコードの「ねじれ」をほどく。決済基盤のリアーキテクチャにRDRAを選んだ理由","contentSnippet":"!この記事は、Linc’well Advent Calendar 2025 10日目 シリーズ 2の記事ですLinc’well - Qiita Advent Calendar 2025 - Qiitaこんにちは！PAYチームの しいたけ です。先日、同チームの竹井から 決済領域に特化した「PAYチーム」が誕生しました！ という記事が公開されました。まだ読まれていない方は、ぜひこちらからご覧ください👇決済領域に特化した「PAYチーム」が誕生しました！前回の記事では、PAYチーム発足の経緯や、「注文（配送）」と「決済」が密結合してしまっているという、技術的負債（レガシーコード...","link":"https://zenn.dev/lincwell_inc/articles/56ec3968161bf1","isoDate":"2025-12-10T00:00:02.000Z","dateMiliSeconds":1765324802000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"iTerm2で初回起動時に決まったディレクトリ開いてコマンドを実行したい","contentSnippet":"この記事は コマンドラインツール／CLI - Qiita Advent Calendar 2025 - Qiita 3日目 の記事ですmacOS のターミナルを使って開発をしていると、「毎日同じディレクトリを開いて同じコマンドを実行している」と感じることはないでし...","link":"https://qiita.com/shitake4/items/0e2ea2679f471161f507","isoDate":"2025-12-02T22:09:03.000Z","dateMiliSeconds":1764713343000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"JetBrains IDE × Marp でMarkdownスライドを快適編集！リアルタイムプレビュー環境の作り方","contentSnippet":"Marpは、Markdownで手軽にスライド資料を作成できるオープンソースツールです。VS Code向けの拡張機能（Marp for VS Code - Visual Studio Marketplace）がよく知られていますが、JetBrains系IDEでもCLIを活用す...","link":"https://qiita.com/shitake4/items/53f2e6911c1da1d7b582","isoDate":"2025-05-19T01:04:36.000Z","dateMiliSeconds":1747616676000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"「伝わるドキュメント」を書くための3つの小さな意識","contentSnippet":"「このドキュメント、何が言いたいのかわからない」「どこを見ればいいか迷う」と感じたことはないでしょうか。社内ドキュメントが読みにくいと、情報共有のスピードや正確性が下がり、プロジェクト全体に悪影響を及ぼします。本記事では、読みやすく、伝わりやすい社内ドキュメントを作成するために意識すべきポイントと、実践的な工夫について紹介します。続きをみる","link":"https://note.com/shitake4_/n/n8155da5820a8","isoDate":"2025-05-08T01:40:24.000Z","dateMiliSeconds":1746668424000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"POは「構造の空白」を埋める存在である","contentSnippet":"プロダクト開発の現場では、「誰がやるのか」が明確でない領域がしばしば生まれます。PO（プロダクトオーナー）は、そうした「構造の空白」に自然と入り込み、状況に応じた柔軟な振る舞いでプロダクトを前進させる役割を担います。本記事では、エンジニア出身の私 @shitake4がPOを経験する中で得た視点をもとに、POという仕事の本質と注意点について考察します。続きをみる","link":"https://note.com/shitake4_/n/n519f97b63085","isoDate":"2025-04-30T23:48:59.000Z","dateMiliSeconds":1746056939000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"ドキュメントは「マスタ」と「スナップショット」に分けて管理する","contentSnippet":"プロジェクトが大きくなるほど、ドキュメントの「何が正しいのか」「いつの情報か」があいまいになり、混乱を招きがちです過去の意思決定や履歴をうまく残しつつ、常に最新の正解を提供するためには、「マスタ」と「スナップショット」に分けてドキュメントを設計・運用する視点が重要になりますこの記事では、以前作成した うまくいくドキュメント運用の視点 - Speaker Deck をさらにブラッシュアップしましたビジネス職とエンジニアが混在するチームでも使いやすいように、実務に応用できる具体的な管理方法を整理しています続きをみる","link":"https://note.com/shitake4_/n/n85c9a260315a","isoDate":"2025-04-22T00:10:37.000Z","dateMiliSeconds":1745280637000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"コードレビュー効率を高めるコミットログの刻み方","contentSnippet":"コードレビューの効率を高めるために、コミットログの扱い方を工夫することは非常に有効です意図が明確な単位でコミットを刻むことが重要です本記事では、レビューしやすいコミットログの作り方とともに、コミット間の差分が持つ意味についても解説します目次目次なぜコミットログを細かく刻む必要があるのか差分が語る「意図」意味が伝わる単位でのコミットの刻み方実際のコミットの分け方の具体例✅ コミット1：UserモデルからUserDecoratorへメソッドを移動するだけbefore（Userモデル内にメソッドがある）after（Userモデルからメソッドを削除、Decoratorへ移動）✅ コミット2：UserDecorator内のメソッドを修正する読みやすいレビューが生むメリット参考資料なぜコミットログを細かく刻む必要があるのかコードレビューでは、変更の意図や影響範囲を素早く正確に把握することが求められますそのため、「1コミット＝1つの意図・目的」という原則でログを構成することで、レビューの精度と速度が格段に向上します差分が語る「意図」Gitを使ったコードレビューでは、git log や git diff でコミット間の差分が参照されますたとえば、以下のような差分を見てみましょう- def display_name-   \"#{first_name} #{last_name}\"+ def display_name+   \"#{last_name} #{first_name}さん\"このような差分がログとして表示されたとき、意図が明確に伝わるコミットメッセージやコミット構成になっていれば、レビュアーは「このコミットは表示形式の改善だ」と一目で理解できます逆に、複数の変更が混在していると、こうした差分が何を意図したものなのかが分からず、レビューの質と速度が落ちます意味が伝わる単位でのコミットの刻み方「細かくコミットを刻む」というと、機械的に1ファイル1コミットのように分けてしまいがちですが、それでは意味が伝わりません実装の「意図」が伝わる単位で分けることが重要ですたとえば次のように考えます：あるメソッドを User クラスから UserDecorator に移動したい移動後、そのメソッドのロジックを改善したいこの場合、1つのコミットで「移動」と「修正」をまとめてしまうのではなく、次のように分けるのが適切です実際のコミットの分け方の具体例✅ コミット1：UserモデルからUserDecoratorへメソッドを移動するだけbefore（Userモデル内にメソッドがある）# app/models/user.rbclass User < ApplicationRecord  def display_name    \"#{first_name} #{last_name}\"  endendafter（Userモデルからメソッドを削除、Decoratorへ移動）# app/models/user.rbclass User < ApplicationRecord  # display_name メソッドを削除end# app/decorators/user_decorator.rbclass UserDecorator < Draper::Decorator  delegate_all  def display_name    \"#{object.first_name} #{object.last_name}\"  endendこのコミットの差分は ロジックの移動のみで、振る舞いは変えていない という意図を明確に伝えます✅ コミット2：UserDecorator内のメソッドを修正する# app/decorators/user_decorator.rbclass UserDecorator < Draper::Decorator  def display_name    \"#{object.last_name} #{object.first_name}さん\"  endendこのコミットの差分では「表示フォーマットを変更した」という意図がコード差分から一目で分かりますこのように分けることで、レビュアーは 「移動した意図」と「ロジックの修正意図」を別々に読み取れる ようになります読みやすいレビューが生むメリットコミットログが読みやすいと、次のようなメリットがありますレビュアーの負担が軽減され、レビューの質が上がる変更の意図が履歴として残るため、将来的な調査や保守に役立つマージやリリース時のトラブルが減る（どこで何が変わったかをトレースしやすいため）これはチーム開発における生産性にも直結するため、普段から意識してコミットを刻むことが大切です参考資料How to Write a Git Commit Message - Chris Beams「コードには How テストコードには What コミットログには Why コードコメントには Why not を書こうという話をした」コミットメッセージアンチパターン: コメント対応 - koicの日記いいコミットメッセージの共通点と書き方〜便利なテンプレートやチーム開発時のお作法まで詳しく解説〜| PrAhaENGINEERLAB","link":"https://blog.shitake4.tech/entry/2025/04/14/%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E5%8A%B9%E7%8E%87%E3%82%92%E9%AB%98%E3%82%81%E3%82%8B%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%83%AD%E3%82%B0%E3%81%AE%E5%88%BB%E3%81%BF?utm_source=feed","isoDate":"2025-04-14T00:55:16.000Z","dateMiliSeconds":1744592116000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Vue.jsコンポーネントのpropsにHTMLElementを型付する","contentSnippet":"Vue.jsのコンポーネントのpropsにHTMLElementを型付しようとしてハマまりました。やろうとしたことはprops: {  element: {type: Object as PropType, required: true}}...","link":"https://qiita.com/shitake4/items/e48ee435efd7106d1eb1","isoDate":"2023-08-30T06:31:31.000Z","dateMiliSeconds":1693377091000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"自分の投稿記事を一箇所に集約して表示する個人用ポートフォリオサイトを作った(Next.js)","contentSnippet":"noteやはてなブログ、Qiitaなど投稿する記事をどこかで1つにまとめられたら嬉しいなと思っていたところ catnoseさん がチーム個々人のテックブログをRSSで集約するサイトを作った（Next.js） を作ってくれました。チーム向けのブログ集約サイトだったため、こちらをForkし、複数のブログプラットフォームに投稿した記事を一箇所に集約して表示する個人用ポートフォリオサイトになるようにしました。デモサイトshitake4/my-post-hub RSSの登録こちらに my-post-hub/author.ts 自分が使用しているサイトを記載します。    { ...","link":"https://zenn.dev/shitake4/articles/bee877c8189d31","isoDate":"2023-07-25T11:26:27.000Z","dateMiliSeconds":1690284387000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"1on1ミーティングで育成・教育を行うために必要なこと","contentSnippet":"1on1ミーティングの狙いのひとつに部下の成長を促すことがあります。僕がはじめてエンジニアリングマネージャー（EM）になった時、「1on1ミーティングを通して教育・育成をどう行えばいいのか？」が分かりませんでした。今回は僕が1on1ミーティングを実践する中で学んだ「教育・育成を考える上で土台となる考え方」や「実際の1on1ミーティング運用方法」を紹介していきたいと思います。続きをみる","link":"https://note.com/shitake4_/n/nb76ddb6c1197","isoDate":"2023-07-20T05:06:59.000Z","dateMiliSeconds":1689829619000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"「とりあえず傾聴」を卒業する：1on1に必要な3つのスキルとは","contentSnippet":"概要Engineering Manager Advent Calendar 2021 のカレンダー2の 21日目の記事です。続きをみる","link":"https://note.com/shitake4_/n/n1094e00563bd","isoDate":"2023-07-20T05:05:47.000Z","dateMiliSeconds":1689829547000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"ShiftitからHammerspoon Shiftitへの移行と設定方法","contentSnippet":"メンテナンスが止まってしまったShiftIt（執筆時2023年7月19日）からHammerspoon ShiftIt へ移行しようとしたのですが、手順や設定周りでつまづきました。今回は私が行った移行手順や設定を紹介していきたいと思います。ShiftItの現状更新が止...","link":"https://qiita.com/shitake4/items/993132be36c96375f4ec","isoDate":"2023-07-20T03:17:36.000Z","dateMiliSeconds":1689823056000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"スクラムを理解するために考えておきたいこと","contentSnippet":"概要スクラム以前にそもそもチームが目指すものは何か？ビジネス価値の最大化（ROIの最大化）ビジネス価値計画通りに進めることの限界初期にすべてを計画し、複雑系をコントロールすることは難しいではスクラムは複雑系をどうやってコントロールするか？仮説、検証のフィードバックループと適応によって複雑性をコントロールしようとしているそもそも経験を得るためには何が必要なのか？フィードバックを得るために必要なことは何か？プロセスの場合インクリメントの場合スクラムイベントでフィードバックを得ている箇所フィードバックループの全体像スクラムではフィードバックループを回すことで、経験を積み、改善を続けることによってビジネス価値を高めているでは、スクラムで定義されている役割の人たちは何をすればいいのか？まとめ参考文献概要こちらはGLOBIS Advent Calendar 2020の23日目の記事です。スクラムの記事を読んでるときに、自分自身で大切にしている核の考え方を書いてみますスクラム以前にそもそもチームが目指すものは何か？ビジネス価値の最大化（ROIの最大化）顧客にとって価値のあるもの（ビジネス価値）を最大化するために、チーム全体で作業をビジネス価値に転換していくことビジネス価値顧客にとって価値のあるもの顧客に見える（顧客とやり取りするオペレーション、顧客が触れるシステムそのもの等）や顧客に見えない（社内のワークフローや分析等）顧客にとっての価値をどう計測するのか？マーケティング的観点NPS, LTV等システム的観点アクティブユーザー数、レスポンスタイム等計画通りに進めることの限界「人々」「要求」「技術」から生じるノイズ（カオスや複雑性）が原因で計画を立てて実行することが難しいまた、当時はMitchell M. Waldropの『Complexity: The Emerging Science at the Edge of Order and Chaos』（邦訳：『複雑系』）が流行し、複雑系やカオス理論に対する関心が高まっていた。ものすごく噛み砕いて言えば、先のことなんかよくわからん！（計画なんて無理じゃね？）という感じ。  参照：勝手に注釈付き参考文献#歴史的な背景プロジェクトの初期は、不確実性が高く見積もりにブレが出やすい。またプロジェクト初期に、すべての情報を出すことは現実的ではない引用：プロジェクトマネジャーのための「プロセス設計術」 - プロジェクトの本質とはなにか：ITpro初期にすべてを計画し、複雑系をコントロールすることは難しいではスクラムは複雑系をどうやってコントロールするか？事前に予測・定義することは諦めているその代わりに以下2つを採用している試行錯誤しながらプロセスを制御していくこと（経験主義）ムダを排除していくこと（リーン思考）※ 作業のサイズを小さくし、リリースまでの全プロセス（計画、実装、テストなど）を経験することによって学びの機会を増やしている仮説、検証のフィードバックループと適応によって複雑性をコントロールしようとしているそもそも経験を得るためには何が必要なのか？経験を得るためには以下の流れが必要実行する → フィードバックを得る → 学びを得る → 経験として蓄積するスクラムイベントをただこなしているだけでは、スクラムでは無いと言われるのは、実行するというフェーズに留まってしまっているからフィードバックを得るために必要なことは何か？プロセスの場合以下の3つのステップが必要計画実行振り返り到達地点を決め（計画）、実行し、実行結果にどんな差分があったかを振り返ることで初めてフィードバックを得ることができる※ 計画をせず、フィードバック得ようとする場合は、何が要因で結果が起こったのかの分析が困難になる為、難易度が高くなるそして得られたフィードバックをプロセスに適用することによって得たフィードバックがプロセスに蓄積される（経験値となる）インクリメントの場合成果物がないと正しくレビューすることができない。また成果物を見て、触ってみて初めてわかることもあるスクラムイベントでフィードバックを得ている箇所スクラムでは、仮説、検証のフィードバックループによってプロセスの制御（経験主義）や、ムダを排除している（リーン思考）プロセス、スプリントによって生み出される成果物（インクリメント）を上記、スクラムイベントで検査しているフィードバックループの全体像引用：© VersionOneスクラムではフィードバックループを回すことで、経験を積み、改善を続けることによってビジネス価値を高めているでは、スクラムで定義されている役割の人たちは何をすればいいのか？プロダクトオーナーROIの最大化ビジネス価値を高めるために、何のリソース（時間、人、金等々）をどうするか？を考える必要があるスクラムマスタープロセスに対するフィードバックループがうまく回るようにチームに対してコーチングメンバースプリントゴールに向けて毎日計画を適応させる（プロセスに問題ないかのチェックや改善）ステークホルダープロダクトに対するフィードバックの提供まとめフィードバックループを回すことに注力するフィードバックループの回数がたくさん回るように工夫するフィードバックループを回すことだけに注力せず、スプリントによってビジネス価値が高まるか？を意識するプロダクト（インクリメント）に対するフィードバック、プロセスに対するフィードバックを意識する参考文献勝手に注釈付き参考文献スクラムガイド日本語版プロジェクトの本質とはなにか不確実性コーンの話 - プログラマでありたいフィードバックループについての分かりやすい資料 | Ryuzee.comアジャイル領域へのスキル変革の指針 アジャイル開発の進め方スクラムを1枚で説明する資料7選（2019年版） | Ryuzee.comアジャイル領域へのスキル変革の指針 アジャイル開発の進め方理解のコツは3つ！アジャイルプロジェクトのプラクティスを3つに分類しよう | Backlogブログ","link":"https://blog.shitake4.tech/entry/2020/12/23/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E8%80%83%E3%81%88%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E3%81%93%E3%81%A8?utm_source=feed","isoDate":"2020-12-22T22:00:00.000Z","dateMiliSeconds":1608674400000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"スプリントレビューについてまとめてみた","contentSnippet":"スプリントレビューとは何か？なぜスプリントレビューをするのか？どうやってスプリントレビューするのか？いつ誰がどうやってスプリントレビューアンチパターン参照スプリントレビューとは何か？プロダクトに対するフィードバックを得るために開くミーティングなぜスプリントレビューをするのか？スクラムチームとステークホルダーで作業の結果をレビューし、振り返ることで、次に取り組むものをより価値の高いものにしていきたいから作業結果に対して複数人による多面的なレビューで、特定の人の先入観や価値観、業務内容による偏りを避けたいからどうやってスプリントレビューするのか？いつスプリントの最終日誰がスクラムチームステークホルダーどうやってプロダクトオーナー（PO）がステークホルダーをスプリントレビューに招待するPOが今回のレビューアジェンダについて説明するスプリントゴールの確認（参照: スプリントゴールについてまとめてみた - そういうこともある）開発チームが今回のスプリントでのインクリメントのデモを実施するPOが以下質問をスクラムチームとステークホルダーに投げかけフィードバックを受け取る利害関係者は、デモの結果を気にいっているか今でも顧客に受け入れられるか重要な機能が不足していないか不必要な機能を作成していないかコストをかけすぎていないか現在のプロダクトバックログ（PBL）の確認POは、PBLのトップをステークホルダーに提示します。スプリントレビューアンチパターン開発チームがPOに向けて動くソフトウェアのデモをしているスプリントレビューで行うのではなく、スプリント期間中に、各アイテムが終わったらすぐにPOは受け入れ条件を確認し、OK/NGの判断をしないといけないスプリントレビューがPOによる検査受入の場になってしまうことスプリントレビューがプロダクトの改善の場ではなく、粗さがしの場になってしまう参照2020-Scrum-Guide-Japanese.pdfスクラムガイド™スプリントレビューの進め方本当のスプリントレビュースプリントレビューとは何ですか？ What is Sprint Review?【保存版】スクラム初心者でも5分で総おさらい！スクラムの超重要単語と導入方法スプリントレビュー - Large Scale Scrum (LeSS)そのスプリントレビューは、機能してますか？ #agile_hiyoko360度多面評価（360どためんひょうか） - ITmedia エンタープライズ","link":"https://blog.shitake4.tech/entry/2020/12/22/%E3%82%B9%E3%83%97%E3%83%AA%E3%83%B3%E3%83%88%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%BF%E3%81%9F?utm_source=feed","isoDate":"2020-12-22T02:11:15.000Z","dateMiliSeconds":1608603075000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"スクラムをやることになったら、はじめに何をやるといいか？","contentSnippet":"概要「スクラム初めまして」からある程度できるようになるまでの流れ1. スクラムイベントとは何をやるのか？と基本的な用語を覚える資料を読んで覚える2. スクラムイベントを実際にこなしながら一通りの流れとやることを覚えていく3. スクラムを改善していくにあたって理解しておくといい方針を覚える資料を読んで覚えるスクラムフレームワークをより理解する為の考え方資料4. （一通りイベントをこなせるようになったら）改善していく改善の為に、理解しておくとよりよいことスクラムはなぜ生産性が上がるのか？あわせて読むとなお良いスクラムについて振り返りについて見積もりについて概要スクラムのことについて何もわからないけど、とりあえず導入してみることになった人や初めてスクラム開発することになった人がどんなことを意識したり考えたらいいのか？を書いていきます「スクラム初めまして」からある程度できるようになるまでの流れスクラムイベントとは何をやるのか？と基本的な用語を覚えるスクラムイベントを実際にこなしながら一通りの流れとやることを覚えていくスクラムを改善していくにあたって理解しておくといい方針を覚える（一通りイベントをこなせるようになったら）改善していく1. スクラムイベントとは何をやるのか？と基本的な用語を覚える資料を読んで覚えるSCRUM BOOT CAMP THE BOOK【増補改訂版】 スクラムチームではじめるアジャイル開発基本的な用語とかをサクッと学ぶならこの本がオススメです。用語を一旦覚えたら後は、習うより慣れろ方式でチームのスクラムイベントをこなしていけば、本が伝えたい内容が段々と分かってくるはずですScrum Guide | Scrum Guidesスクラムでやることや基本的な事項は、ここに書いてあります。ただ最初の方は抽象的に感じることが多かったり、どうすればいいんだろうと迷うことになったりします。そのため、チームでスクラムを改善していくときに、その改善はスクラムガイドから外れたものでは無いか？と確認するために最初は使うといいです2. スクラムイベントを実際にこなしながら一通りの流れとやることを覚えていくまずはチーム内でスクラムイベントをこなしてみましょう。進めていくとこのスクラムイベントはなんでやってるんだろう？こっちのほうがもっと効率的では？などと感じることが多いと思います。そのタイミングで書籍や資料を見返して考えていく必要があります3. スクラムを改善していくにあたって理解しておくといい方針を覚える資料を読んで覚えるスクラムフレームワークをより理解する為の考え方アジャイルソフトウェア開発宣言が上位概念として存在しますスクラムを改善するときは、「アジャイルソフトウェア開発宣言」や「スクラムガイド」から外れていないか？を確認する必要があります資料アジャイルソフトウェア開発宣言アジャイル宣言の背後にある原則4. （一通りイベントをこなせるようになったら）改善していく改善の為に、理解しておくとよりよいことスクラムはなぜ生産性が上がるのか？制約理論をベースに、Work In Process（WIP）を無くすことでチームとしてのアウトプット量を増やせるからです制約理論参考本：ザ・ゴール コミック版コンテキストスイッチを排除することメンバーが2つ以上のタスクを実行しないことで、コンテキストスイッチの発生を防いでおり、一人の仕事量を最大化できます参考:プロジェクト切り替えのムダに関するワインバーグの表あわせて読むとなお良いスクラムについてエッセンシャル スクラムスクラムの教科書として全体感と詳細を学べる。また実際の現場にどうフィットさせるか？も記述されているので、かなりおすすめですカイゼン・ジャーニー たった1人からはじめて、「越境」するチームをつくるまで周囲を巻き込みながら組織を変えていくという物語の為、どういうことがチームに起こって、そこでどんな改善をしていくのか？のイメージがつきやすいですスクラム　仕事が４倍速くなる“世界標準”のチーム戦術 (早川書房)スクラムを造ったジェフ・サザーランド氏がスクラムについてまとめた書籍で、スクラムを理解して自分の中で落とし込んでいくために読むのにおすすめです振り返りについてこれだけ！　ＫＰＴ 【これだけ！シリーズ】KPTフレームワークを理解するのに便利です。KPTを更に進化させる方法なども記載されていて取り組みやすいです見積もりについてアジャイルな見積りと計画づくり ～価値あるソフトウェアを育てる概念と技法～見積もりや計画の立て方で迷うことが多いのではないかと思われます。その際の指針になってくれる本です","link":"https://blog.shitake4.tech/entry/2020/12/17/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0%E3%82%92%E3%82%84%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F%E3%82%89%E3%80%81%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB%E4%BD%95%E3%82%92%E3%82%84?utm_source=feed","isoDate":"2020-12-17T02:11:44.000Z","dateMiliSeconds":1608171104000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"スプリントゴールについてまとめてみた","contentSnippet":"スプリントゴールとは何か？なぜスプリントゴールを設定するのか？スプリントゴールがないことによる問題どうやってスプリントゴールを設定するか？いつ誰がどうやって参考資料スプリントゴールとは何か？スプリント期間に達成したい目標の概要（ビジネスの目的と価値を１,2文でまとめたもの）実装、変更をする際の基準としてスプリントゴールを利用可能スプリントゴールの例：ECアプリケーションショッピングカートの数量を追加、削除、更新するチェックアウトプロセスを開発する：注文の支払い、配送の選択、注文のギフトラッピングなぜスプリントゴールを設定するのか？バックログアイテムは、作業可能なタスクとして記載されている為、単純にタスクをこなして完了条件さえ満たせばいいと考えてしまいがち本当に達成したいことは、タスクの完了ではなくスプリントゴールで示す価値の提供である為、修正や判断が必要な時に方針とし、意思決定に柔軟性を持たせるため１つの目標を共有し、チームが一致団結するため個々のタスクをなぜ作るかを開発チームが知ることでモチベーションを高めるため例：イソップ寓話「3人のレンガ職人」に学ぶ、モチベーション高く働く従業員を育てるヒント - 株式会社トータル・エンゲージメント・グループスプリントゴールがないことによる問題スプリントゴールが無い = 明確な判断基準が無い為、細かい調整や判断に時間がかかり、やがて集中力が途切れてしまう開発チームが下請け扱いされているまたはビジネスに関心が薄い状態になるどうやってスプリントゴールを設定するか？いつスプリントプランニングの最初誰がプロダクトオーナー（PO）が決めるどうやってPOが、現在のスプリントで製品の価値と有用性をどのように高めることができるかをチームに提案するチームは、スプリントの作業内容について話し合い、決定するチームはスプリントのスプリントゴールを作成する参考資料スクラムのスプリントゴールとは何ですか？ What is a Sprint Goal in Scrum? : warren_lynchのblogスプリントゴールって何なんだ!? 「スクラムガイドを読み解いてみよう」に参加しました - Qiitaスプリントゴールの効果 - アジャイルコーチの備忘録Scrum Guide | Scrum Guides","link":"https://blog.shitake4.tech/entry/2020/12/15/%E3%82%B9%E3%83%97%E3%83%AA%E3%83%B3%E3%83%88%E3%82%B4%E3%83%BC%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%BF%E3%81%9F?utm_source=feed","isoDate":"2020-12-15T08:14:28.000Z","dateMiliSeconds":1608020068000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"うまくいくドキュメント運用の視点","contentSnippet":"","link":"https://speakerdeck.com/shitake4/umakuikutokiyumentoyun-yong-falseshi-dian","isoDate":"2020-06-02T04:43:23.000Z","dateMiliSeconds":1591073003000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"議論を進めるファシリテーション","contentSnippet":"参考書籍\rファシリテーションの教科書―組織を活性化させるコミュニケーションとリーダーシップ","link":"https://speakerdeck.com/shitake4/yi-lun-wojin-meruhuasiritesiyon","isoDate":"2020-05-15T04:17:35.000Z","dateMiliSeconds":1589516255000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Rails Developers Beer Bash 〜Railsのトレンドとこれから〜に行ってきました","contentSnippet":"概要今回参加したイベントはこちらになりますtechplay.jphttps://Twitter.com/shitake4/status/1177167806707593216最近、Railsの勉強会に参加できてなかったので、最新情報とかいろいろとキャッチアップできればな〜と思い参加しました概要参加したセッション1. 2週間で Rails 5.1 > Rails 6 タイムアタックチャレンジ参加にあたって、特に気になっていたところ1. アップデートに関して気を付けることは何か？2. ボトルネックになりそうなことは何か？感想2. Multi DBを実戦投入するときの落とし穴参加にあたって、特に気になっていたところ1. 投入する上でのハマりどころ感想3. Railsパネルディスカッション参加にあたって、特に気になっていたところ1. Rails 6でうれしい機能は？2. Railsでマイクロサービスはどうやってやるのか？3. Railsと技術的負債の付き合い方は？感想LTのスライド今日一日の感想参加したセッション2週間で Rails 5.1 > Rails 6 タイムアタックチャレンジMulti DBを実戦投入するときの落とし穴Railsパネルディスカッション1. 2週間で Rails 5.1 > Rails 6 タイムアタックチャレンジ speakerdeck.com参加にあたって、特に気になっていたところアップデートに関して気を付けることは何か？ボトルネックになりそうなことは何か？1. アップデートに関して気を付けることは何か？DEPRECATION WARNING はできるだけ消すbackportして先にリリースで安心感を得られる主要機能は、手動で動作確認決済機能など2. ボトルネックになりそうなことは何か？リリースノートは読んでおき、脳内インデックスを作っておくとスピードが増すWARNING を消す際に必要な作業感想Railsアップグレードする場合は、なるべく小さくリリースしていくのが大事主要機能はやはり手動で動作確認するの大事なんだと思いました2. Multi DBを実戦投入するときの落とし穴    Rails 6 Multi-DB 実戦投入  from kiyots  www.slideshare.net参加にあたって、特に気になっていたところ投入する上でのハマりどころ1. 投入する上でのハマりどころprimary にトランザクション貼っているかreplica に貼っているかを意識する必要がある便利なmiddlewareのハマりどころHTTPメソッドにもとづいて read/writeを自動で決定するのが、不適切な場合があるmiddlewareは使わず、 around_action で行う6.0.0 のdelay機能は曲者書き込みDBにアクセスしたあとGET/HEADも書き込み用DBにつなぐ書き込み用DBにつないでいる状態で、書き込み系クエリを投げるとエラーが発生する感想MultiDBは結構ハマりどころが多そうだったので、非常に学びがあった3. Railsパネルディスカッション参加にあたって、特に気になっていたところRails 6でうれしい機能は？Railsでマイクロサービスはどうやってやるのか？Railsと技術的負債の付き合い方は？1. Rails 6でうれしい機能は？MultiDBが GitHub - eagletmt/switch_point: Switching database connection between readonly one and writable one を使用しなくてもいいのがうれしいenumのnegative scope参照：Rails6 のちょい足しな新機能を試す44（enum 編） #Ruby - QiitaBigBinary Blog: Insights on Ruby on Rails, React & MoreAction Cableのテストが標準化されていることRails 6のB面に隠れている地味にうれしい機能たち（翻訳）｜TechRacho by BPS株式会社並列testが標準でできること2. Railsでマイクロサービスはどうやってやるのか？Railから大きくハズレないRailに乗っているところが巨大化するものは問題ない認証周りなど境界づけられたコンテキストごとにマイクロサービスして巨大化したコードベースを分割する3. Railsと技術的負債の付き合い方は？依存ライブラリがRails 6に対応していないとアップグレードするのが、だいぶつらいテストカバレッジが高いことがアップグレードを助けてくれるバグを減らす日を設けて、継続的に負債を返却しているGitHub Advanced Security · Built-in protection for every repository · GitHub で継続的にGemのバージョンアップをしているモデルのレイヤをモデル層とデータ層に分割している感想各社の工夫の部分だったり、Railsで大きいサービスを作る場合の設計の指針はどうすればいいのか？など非常に学びがありましたLTのスライドスライド/2019/09/26/Rails Developers Beer Bash 〜Railsのトレンドとこれから〜/GitHub Actionsで複数DBテスト #railsbeerbash - esa-pages.ioBeyond Active Record - Speaker Deck今日一日の感想上記セッション以外にも懇親会 & LT大会 もあったのですが、翌日に作業があったため、途中で退室しました 💨読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/09/26/Rails_Developers_Beer_Bash_%E3%80%9CRails%E3%81%AE%E3%83%88%E3%83%AC%E3%83%B3%E3%83%89%E3%81%A8%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E3%80%9C%E3%81%AB%E8%A1%8C%E3%81%A3%E3%81%A6%E3%81%8D%E3%81%BE%E3%81%97?utm_source=feed","isoDate":"2019-09-26T11:43:07.000Z","dateMiliSeconds":1569498187000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Feedly、Webプッシュでサイトの購読ができるようになりました | サイト更新情報","contentSnippet":"TL;DRFeedlyで登録できるようにボタン作りましたその他RSSで登録できるようにボタン作りましたWebプッシュで通知が受け取れるようにボタンを作りました画面PCの場合は、画面右のサイドバー上部SPの場合は、画面下の記事下部できるようになったこと1. Feedlyで登録できるようにボタン作りました今までも更新フィードは https://blog.shitake4.tech/feed で受け取れましたはてなブログでは、自動ですべてのブログについてAtomフォーマットおよびRSS 2.0フォーマットによる更新フィードを、ブログ全体およびカテゴリーごとに配信しています。 フォーマット  URL  Atom  http://ブログのドメイン/feed  RSS 2.0  http://ブログのドメイン/rss 引用 : 更新フィード - はてなブログ ヘルプただ、Feedlyで登録する際には以下のステップが必要でしたfeedlyを開くhttps://blog.shitake4.tech で検索登録するそのため、簡単に購読できるように、ボタンを設置し、1, 2のステップを１クリックで済ませられるようにしました2. その他RSSで登録できるようにボタン作りましたこちらも 1. Feedlyで登録できるようにボタン作りました と同様に登録をなるべく簡単にするようにボタンを作成しました3. Webプッシュで通知が受け取れるようにボタンを作りました否定的な意見も見られるWebプッシュですが、【ウザい】ウェブサイトからブラウザに届く通知（Web Push）を無効化、ブロックする方法 – Chrome、Firefox、Edgeで通知をオフにする手順まとめ - usedoorWeb Pushのウザったさに思う「情報の押しつけ」Web Pushの許可願いがウザいので遮断する - Yotazo Lab.突然表示される「Webプッシュ」は早急に滅んで欲しい - Hagex-day info参考：サイト訪問時に、確認ダイアログを表示する方法は利用していません購読を外したい場合は、同じボタンを押下し、遷移先で購読解除することができます","link":"https://blog.shitake4.tech/entry/2019/09/21/Feedly%E3%80%81Web%E3%83%97%E3%83%83%E3%82%B7%E3%83%A5%E3%81%A7%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%B3%BC%E8%AA%AD%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A?utm_source=feed","isoDate":"2019-09-21T10:25:33.000Z","dateMiliSeconds":1569061533000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"お名前.comからGoogle Domainsに移管するやりかた","contentSnippet":"2019/09/09時点の情報です概要個人的に、お名前.comのサイトが少し使いにくいこともあり、別のサービスを利用しようかと考えていたところTwitterで、Google Domainsに移行したというツイートをみたこともあり自分は最近全ドメインGoogle Domainsに移行してた。 https://t.co/FylqMGtRsr— chidakiyo (@chidakiyo) 2019年9月9日   これを機に移管してみました概要前提Google Domainsのメリット移行手順1. Google DomainsページのMy domainから管理画面へ遷移する2. 画面左の 移管 をクリックする3. ドメイン名を入力して、移管可能か確認する4. gTLDの移管に認証コードが必要な為、お名前.comの認証コードを確認する5. Google Domainsの「認証コードを入力してください」と書かれた入力フォームに AuthCode を入れる6. 1年分の移管費用を支払い、移管作業を申請する7. Googleから確認のメールが送られてくる感想前提Googleアカウントが作成済みであることGoogleアカウントでログインしていることGoogle Domainsのメリットメリットは、Google Domainsサイトトップにも書かれていますが、余計なコストがいらない（ドメインにまつわる処理に追加料金がかからないということ）簡単にWebサイトが作れる（サイト構築サービスと連携ができる）G Suiteでメールアドレスが作れる（これはもうGoogleサービスならでは）数年の間に何百ものトップレベルドメイン が利用可能になる（まだまだ増えるのでしょう）最大100ものサブドメインをカスタマイズできる（管理画面から可能になるようです）高速で安全で信頼性の高いGoogleのインフラ（GoogleのDNSが利用できる意義は大きそう）シンプルなドメイン管理ツール（そもそもGoogleアカウントで管理できるメリットもある）メールの転送（G Suiteを使わず転送が可能になるようです）という特徴があります。引用：その独自ドメイン、Googleに移管してみない？Google Domainsが日本から利用可能になっていたのでドメインを移管してみた。移行手順1. Google DomainsページのMy domainから管理画面へ遷移するGoogle Domainsこちらの My domains ボタンをクリックする2. 画面左の 移管 をクリックする3. ドメイン名を入力して、移管可能か確認する4. gTLDの移管に認証コードが必要な為、お名前.comの認証コードを確認するお名前.com Naviログインドメイン一覧のドメイン詳細画面の表の AuthCode の右に 表示する ボタンがあるので、こちらをクリックして AuthCode を表示するこちらをクリックすると表示されますそして、表示された AuthCode をコピーする5. Google Domainsの「認証コードを入力してください」と書かれた入力フォームに AuthCode を入れる4.でコピーした AuthCode を入力し、続行ボタンを押下するするとお名前.comで登録していた情報が一覧で表示されます6. 1年分の移管費用を支払い、移管作業を申請する移管費用は、ドメインの更新費用1年分です一旦ステータスは移管中になります7. Googleから確認のメールが送られてくる登録したメールアドレスに確認のメールが送られてくるので、「メールアドレスを確認」ボタンをクリックして完了です感想移行自体は非常に簡単でした。 Gsuiteが使えるようになるので、色々と活用してみたいと思います参照：その独自ドメイン、Googleに移管してみない？Google Domainsが日本から利用可能になっていたのでドメインを移管してみた。Google Domainsでドメイン買ったらSSL証明までついてきたGoogle DomainsでWhois代行とDNSSECを格安運用読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/09/14/%E3%81%8A%E5%90%8D%E5%89%8D.com%E3%81%8B%E3%82%89Google_Domains%E3%81%AB%E7%A7%BB%E7%AE%A1?utm_source=feed","isoDate":"2019-09-14T09:19:21.000Z","dateMiliSeconds":1568452761000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"銀座Rails#13のセッションを見てみました","contentSnippet":"概要銀座Rails#13 @リンクアンドモチベーション - connpass前から開催されていおり、気になっていた銀座Railsについに参加しようと思い応募してみましたが、当日は、別の予定が入ってしまい泣く泣く参加できずなので、オンラインで公開されているスライドやTwitterなどから気になっていたことなどをまとめてみます概要当日開催されたセッション出張Railsウォッチ in 銀座Rails参加にあたって、特に気になっていたところ1. 今月のRailsの動きの最新情報Action Text2. 情報の仕入れ方の話とかあれば、それを知りたい感想fixture再考参加にあたって、特に気になっていたところ1. 通常とは違うfixtureの話であればそれの使い方感想RailsとJSのデータ橋渡しについて考えてみた参加にあたって、特に気になっていたところ1. DOMとAPIでのパフォーマンスなどの違い感想Railsのパフォーマンスをチューニングしてみる話参加にあたって、特に気になっていたところ感想今日一日の感想当日開催されたセッション出張Railsウォッチ in 銀座Railsfixture再考RailsとJSのデータ橋渡しについて考えてみたRailsのパフォーマンスをチューニングしてみる話出張Railsウォッチ in 銀座Rails speakerdeck.com参加にあたって、特に気になっていたところ今月のRailsの動きの最新情報情報の仕入れ方の話とかあれば、それを知りたい1. 今月のRailsの動きの最新情報Action TextWhat Yout See Is What You Get画面で見えているものと出力されるものが同じになるUIのことなぜ嬉しいのか？アップロード周りの取り扱いが楽になるラピッドプロトタイピング開発で考えることが減る印象最低限の手間でサクッと画像・ファイルアップロードまで動くのは良い現代最低限求められる挙動を満たしている定義済みスタイルや機能は少ない2. 情報の仕入れ方の話とかあれば、それを知りたいここらへんの話は特にありませんでした  MySQLパフォーマンスチューニングTIPSOptimizing Ruby with JITFaker2Shrine 3.0感想Action Textは、まだ触ってなかったので、使ってみた感触などが把握できてよかったfixture再考 t.co参加にあたって、特に気になっていたところ通常とは違うfixtureの話であればそれの使い方1. 通常とは違うfixtureの話であればそれの使い方メリット テストデータの生成が早いvs FactoryBotuse_transactional_test との相性が良いdev.toのテストデータを書き換えて、速度検証約13秒の実行時間の減少感想fixtureはmasterデータ生成くらいでしか、使ってなかったので、使い所次第では有用なことが理解できて勉強になりましたRailsとJSのデータ橋渡しについて考えてみた speakerdeck.com参加にあたって、特に気になっていたところSSRとAPIでのパフォーマンスなどの違い1. DOMとAPIでのパフォーマンスなどの違いAPI表示し始めが早いAudits判定が早いDOM表示終わりが早い感想それぞれの違いが明確になって、理解できたRailsのパフォーマンスをチューニングしてみる話TODO: - スライドを入れる参加にあたって、特に気になっていたところパフォーマンスチューニングする際の手順どこがボトルネックになりやすい？パフォーマンスチューニングするにあたって気をつけること感想TODO:今日一日の感想Rails関連の最新情報や普段使用している機能の深い考察など学びが非常に多かったので、次回こそは参加できるように予定を調整したい 💪読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/09/13/%E9%8A%80%E5%BA%A7Rails%2313%E3%81%AE%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E8%A6%8B%E3%81%A6%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F?utm_source=feed","isoDate":"2019-09-13T06:59:27.000Z","dateMiliSeconds":1568357967000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"builderscon tokyo 2019に行ってきました","contentSnippet":"2019/08/23のbuildersconに参加してきました参加したセッションメルペイ開発の裏側RDBのトラブルの現場を追え！Web API に秩序を与える Protocol Buffers 活用法Optimizing Ruby with JIT - 最速の言語を目指してウォレットアプリ「Kyash」の先 〜「Kyash Direct」のアーキテクチャ〜メルペイ開発の裏側 t.coメルペイ開発の裏側参加にあたって、特に気になっていたところデータ整合性の担保をどうしているのか？ロールバックはどうしているのか？1. データ整合性の担保をどうしているのか？基本はリトライし、継続不可能なときのみ、処理をやめるようですリトライと冪等性- どんなエラーが出ても基本的にリトライする- 冪等性を担保して二重処理されないようにする- 継続不可能なときのみ処理をやめる引用：P.22リコンサイル［名］(スル)《一致させる、の意》複数帳簿間で残高照合を行うこと。また、金融関連では外国の銀行に保有する口座の取引明細と、自行の処理した取引明細と照合すること。引用：リコンサイルすることで、データの整合性を担保しているそうですデータの整合性を確認すること- 会計データが完全な状態だということを保証する- 各マイクロサービスと会計システム間引用：P.292. ロールバックはどうしているのか？状態遷移モデルを採用し、どんな処理でも意図せず落ちることがある為、処理単位を記録するように状態を定義しているようですロールバックも状態遷移で定義- 途中で継続不可能（tryが失敗）した場合も遷移先が異なるだけ- Cancelを行う状態を定義して一貫したモデルで扱う引用：P.25感想トランザクション管理はやはり難しそうで、データ整合性を担保する為に、かなり安全に倒して設計されているんだなと思いましたRDBのトラブルの現場を追え！ speakerdeck.comRDBのトラブルの現場を追え！参加にあたって、特に気になっていたところどうやって障害理由を切り分け、そして対応してきたのか？1. どうやって障害理由を切り分け、そして対応してきたのか？壊れたとは何かをちゃんと特定することたとえば、突然パフォーマンスが悪化したデータの不整合が発生しているデータベースが応答を返さないコネクションが溢れている間違えてDROP TABLEしちゃった（バルス）引用感想これは知らないDBの機能でしたMySQLだと beginしても DROP TABLEするとauto commitが走って消えるバルクインサートより、MySQLならLOAD、PostgreSQLならCOPYが早いテキストファイルからテーブルをロードする場合は LOAD DATA INFILE を使用します。通常、これは INSERT ステートメントを使用する場合より、20 倍速くなります。セクション13.2.6「LOAD DATA INFILE 構文」を参照してください。引用：8.2.2.1 INSERT ステートメントの速度 PostgreSQLはこちらPostgreSQL に大量のデータを高速に取り込む方法を紹介します。 COPY という専用のコマンドを使うと INSERT よりもずっと高速です。 また、COPY を使う際にひと工夫すると、さらに速くなります。引用：大量のデータを高速に投入するにはB-Treeインデックスは全体の10%くらいのデータ量じゃないとインデックス効かないWeb API に秩序を与える Protocol Buffers 活用法 speakerdeck.comWeb API に秩序を与える Protocol Buffers 活用法参加にあたって、特に気になっていたところWeb APIのSchema管理について1. Web APIのSchema管理について.proto ファイルを記述して、コードを自動生成する豊富なpluginでswagger.jsonの生成も可能感想実装よりも振る舞いに集中するして開発できるのはかなり楽だなと思いました  .proto file 自体もシンプルに見えるので、学習コストもあまりかからず導入できそうだなと感じましたOptimizing Ruby with JIT - 最速の言語を目指して t.coOptimizing Ruby with JIT - 最速の言語を目指して参加にあたって、特に気になっていたところRubyのJust-In-Timeコンパイラがいかにしてそのような言語の高速化を実現しているかのエッセンス1. RubyのJust-In-Timeコンパイラがいかにしてそのような言語の高速化を実現しているかのエッセンス機械語にしただけでは、早くならない処理を減らすことが最適化への道感想JIT コンパイラが何をやっているのか？を知らなかったので、ここが学べたのは、非常に大きいなと思いましたウォレットアプリ「Kyash」の先 〜「Kyash Direct」のアーキテクチャ〜 t.coウォレットアプリ「Kyash」の先 〜「Kyash Direct」のアーキテクチャ〜参加にあたって、特に気になっていたところいろいろな設計を行っているが運用してみてどうだったのか？DDDClean ArchitectureMicroservicesOrchestration/ChoreographyMessage Pub/SubEvent Driven Architecture/Event SourcingCQRS分散Tracing1. いろいろな設計を行っているが運用してみてどうだったのか？運用はこれからなので、まだまだ試行錯誤が続きそう。。。とのことでしたマイクロサービスの選択理由モノリスにするには巨大で複雑すぎる部分的な変更が全体に影響を及ぼすのを避けたい部分ごとに負荷が大きく異なる外部サービスとの接続部分を切り離しておきたい機能追加のスピードは極力落としたくないPros.各サービス単体では、小さくてシンプル変更の影響を局所化できるスケールしやすいデプロイしやすいリソース配分を最適化しやすいCons.設計・実装が難しい感想イベントドリブンアーキテクチャの設計を見たことがなかったので、ここまで難しいのかということと、かなり複雑なアーキテクチャで運用がつらそうと思ったが、エンジニアとしてはかなり刺激的だなと思いました今日一日の感想仕事でもすぐに生かしていけそうな知識からエンジニアとしての基礎力を上げるような内容まで幅広く非常に楽しめた一日でした※ 当日貰ったTシャツとバック読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/08/30/builderscon_tokyo_2019%E3%81%AB%E8%A1%8C%E3%81%A3%E3%81%A6%E3%81%8D%E3%81%BE%E3%81%97%E3%81%9F?utm_source=feed","isoDate":"2019-08-30T08:48:13.000Z","dateMiliSeconds":1567154893000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support subclasses編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所subclasses を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますsubclassesメソッドはレシーバのサブクラスを返します。class C; endC.subclasses # => []class B < C; endC.subclasses # => [B]class A < B; endC.subclasses # => [B]class D < C; endC.subclasses # => [B, D]返されるクラスの順序は一定ではありません。引用：RAILS GUIDES：subclassesソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def subclasses を探してみます2. 該当箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > class > subclasses.rbclass Class省略  # Returns an array with the direct children of +self+.  #  #   class Foo; end  #   class Bar < Foo; end  #   class Baz < Bar; end  #  #   Foo.subclasses # => [Bar]  def subclasses    subclasses, chain = [], descendants    chain.each do |k|      subclasses << k unless chain.any? { |c| c > k }    end    subclasses  endendまず、一行目から見ていきます  def subclasses    subclasses, chain = [], descendants多重代入を行い、2つの変数の初期化をしていますRubyリファレンスの多重代入を見てみます多重代入例:foo, bar, baz = 1, 2, 3foo, = list()foo, *rest = list2()文法:   式 [`,' [式 `,' ... ] [`*' [式]]] = 式 [, 式 ... ][`*' 式]   `*' [式] = 式 [, 式 ... ][`*' 式]</p>引用：Ruby 2.6.0 リファレンスマニュアル：多重代入今回の場合だと、 変数 subclasses は空の配列で初期化、 変数 chain は descendants メソッドの戻り値で初期化されていますdescendants というメソッド名から推測すると、 descendant は子孫という意味、複数形の s が付く為、 継承チェインのオブジェクトの配列が戻り値では無いかと思われます次の処理を見ていきます  chain は継承チェイン上にあるオブジェクトの配列を each で1つずつ取り出していますchain.each do |k|  subclasses << k unless chain.any? { |c| c > k }endまずは、unless 修飾子を読んでみますunless chain.any? { |c| c > k }any? は真である要素があれば、trueを戻り値とし、無ければfalseを返します参照：Enumerable#any? (Ruby 3.4 リファレンスマニュアル)今回はブロックがある為、ブロックの条件を満たす場合に、trueを返し、満たさない場合は、falseになりますブロック内の処理を見ると、配列 chain と eachで取り出した、 k を比較しています参照：module Comparable (Ruby 3.4 リファレンスマニュアル)例えば、class Cを継承した B, D がある場合class C; endC.subclasses # => []class B < C; endC.subclasses # => [B]class D < C; endC.subclasses # => [B, D]Cに対して、 descendants を実行すると以下になりますつまり、変数 chain は [D, B] です改めて、eachの処理を見ますchain.each do |k|  subclasses << k unless chain.any? { |c| c > k }endブロック引数 k が D となりますchain.any? { |c| c > k } を見ると、c は D の場合は、D > D で falsec は B の場合は、B > D で falseですsubclasses に ブロック引数 k が追加されます次のループでは、ブロック引数 k が B となりますchain.any? { |c| c > k } を見ると、c は D の場合は、D > B で falsec は B の場合は、B > B で falseですsubclasses に ブロック引数 k が追加されますすると変数 subclassesは [D, B] ですメソッドの処理全体を見ていくと  def subclasses    subclasses, chain = [], descendants    chain.each do |k|      subclasses << k unless chain.any? { |c| c > k }    end    subclasses  end変数 subclasses を戻り値としています読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/08/07/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_subclasses%E7%B7%A8?utm_source=feed","isoDate":"2019-08-07T02:26:38.000Z","dateMiliSeconds":1565144798000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support cattr_reader編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所cattr_reader を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますこれらのメソッドは、クラス変数をnilに設定し (クラス変数が既にある場合を除く)、対応するクラスメソッドを生成してアクセスできるようにします。class MysqlAdapter < AbstractAdapter  # @@emulate_booleansにアクセスできるクラスメソッドを生成する  cattr_accessor :emulate_booleans, default: trueend引用：RAILS GUIDES：4.1.2 cattr_reader、cattr_writer、cattr_accessorソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def cattr_reader を探してみます該当する定義がないので cattr_reader で探します検索結果内に aliasメソッドがあったので、実際の定義は mattr_reader のようですalias :cattr_reader :mattr_readerいつも通りコードリーディングしながら記事を書いていたんですが、以前 mattr_reader 読んでいたので、泣く泣くそれは破棄しましたmattr_reader のコードリーディング記事のリンク貼っておきますblog.shitake4.tech読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/08/06/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_cattr_reader%E7%B7%A8?utm_source=feed","isoDate":"2019-08-06T03:42:11.000Z","dateMiliSeconds":1565062931000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Rails のソースコード読んでみる | Active Support class_attribute 編","contentSnippet":"普段仕事で使っている Ruby on Rails ですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所class_attribute を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます4.1.1 class_attributeclass_attributeメソッドは、1つ以上の継承可能なクラスの属性を宣言します。そのクラス属性は、その下のどの階層でも上書き可能です。class A  class_attribute :xendclass B < A; endclass C < B; endA.x = :aB.x # => :aC.x # => :aB.x = :bA.x # => :aC.x # => :bC.x = :cA.x # => :aB.x # => :b引用：RAILS GUIDES：class_attributeソースコードを読んでみる1. rails プロジェクトの activesupport にある機能ですので、activesupport ディレクトリの lib 配下で def class_attibute を探してみます2. 該当箇所が 1 箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > class > attribute.rb# frozen_string_literal: truerequire \"active_support/core_ext/kernel/singleton_class\"require \"active_support/core_ext/module/redefine_method\"require \"active_support/core_ext/array/extract_options\"class Class省略  def class_attribute(    *attrs,    instance_accessor: true,    instance_reader: instance_accessor,    instance_writer: instance_accessor,    instance_predicate: true,    default: nil  )    attrs.each do |name|      singleton_class.silence_redefinition_of_method(name)      define_singleton_method(name) { default }      singleton_class.silence_redefinition_of_method(\"#{name}?\")      define_singleton_method(\"#{name}?\") { !!public_send(name) } if instance_predicate      ivar = \"@#{name}\".to_sym      singleton_class.silence_redefinition_of_method(\"#{name}=\")      define_singleton_method(\"#{name}=\") do |val|        redefine_singleton_method(name) { val }        if singleton_class?          class_eval do            redefine_method(name) do              if instance_variable_defined? ivar                instance_variable_get ivar              else                singleton_class.send name              end            end          end        end        val      end      if instance_reader        redefine_method(name) do          if instance_variable_defined?(ivar)            instance_variable_get ivar          else            self.class.public_send name          end        end        redefine_method(\"#{name}?\") { !!public_send(name) } if instance_predicate      end      if instance_writer        redefine_method(\"#{name}=\") do |val|          instance_variable_set ivar, val        end      end    end  endまず class_attribute の引数からみてみます  def class_attribute(    *attrs,    instance_accessor: true,    instance_reader: instance_accessor,    instance_writer: instance_accessor,    instance_predicate: true,    default: nil  )attrs は可変長引数で instance_accessor などの引数はキーワード引数です参照：Rubyの引数いろいろ #Ruby - Qiitaそれぞれ以下のように挙動しますclass A  def self.hoge(*attrs, huga: 'a')    p '==attrs=='    p attrs    p '==huga=='    p huga  endend=> A.hoge(1,2,3, huga: 'b')\"==attrs==\"[1, 2, 3]\"==huga==\"\"b\"それではメソッドの中身を見ていきますattrs.each do |name|  singleton_class.silence_redefinition_of_method(name)  define_singleton_method(name) { default }  singleton_class.silence_redefinition_of_method(\"#{name}?\")  define_singleton_method(\"#{name}?\") { !!public_send(name) } if instance_predicate  ivar = \"@#{name}\".to_symattrs は先程の可変長引数で配列になります。配列の要素を each で１つずつ取り出して処理していますeach の中の処理を見ていきますsingleton_class.silence_redefinition_of_method(name)singleton_class メソッドでレシーバの特異クラスを戻り値とします参照：Object#singleton_class (Ruby 3.4 リファレンスマニュアル)silence_redefinition_of_method は active_support > core_ext > module > redefine_method.rb に定義されているメソッドです@y-yagi さんのブログに記載がありましたので、こちらを引用させて頂きます普通にメソッドを再定義しようとすると既にメソッドがある為Rubyのwarningが発生します。それを避ける為、今まではremove_possible_methodメソッドを先に呼び出してメソッドを未定義にするようにしていました(redefine_methodメソッド内でもそのような挙動になっています)。が、メソッドを再定義する、という事をする為にメソッドを未定義にする、というのは目的がわかりにくいのでは、という事で新たにremove_possible_methodを使用せずに再定義するメソッドが追加されました。実装は下記の通りです(Ruby 2.3以降の場合)。# Marks the named method as intended to be redefined, if it exists.# Suppresses the Ruby method redefinition warning. Prefer# #redefine_method where possible.def silence_redefinition_of_method(method)  if method_defined?(method) || private_method_defined?(method)    # This suppresses the \"method redefined\" warning; the self-alias    # looks odd, but means we don't need to generate a unique name    alias_method method, method  endendalias_methodを使用して対応しているんですねえ。引用：rails commit log流し読み(2017/09/01)処理自体はメソッドの再定義をRubyのエラーを表示させず、実行できるものです次の行を見てみます  define_singleton_method(name) { default }define_singleton_method は、レシーバにシングルトンのメソッドを追加できるメソッドですdefine_singleton_method(symbol, method) → symboldefine_singleton_method(symbol) { block } → symbol引用：Rubyドキュメント2.6define_singleton_method の引数とブロック内の default にそれぞれ何が入るかはname は、可変長引数 attrs の各要素で、ブロック内の default は引数のdefaultが入ります  def class_attribute(    *attrs,    instance_accessor: true,    instance_reader: instance_accessor,    instance_writer: instance_accessor,    instance_predicate: true,    default: nil  )    attrs.each do |name|      singleton_class.silence_redefinition_of_method(name)      define_singleton_method(name) { default }次の行をみます  singleton_class.silence_redefinition_of_method(\"#{name}?\")違いは name? にしているところです? が付くメソッドは、booleanを返すメソッドです次の行をみます  define_singleton_method(\"#{name}?\") { !!public_send(name) } if instance_predicateinstance_predicate はメソッドの引数の値でデフォルト値が true のものですdefine_singleton_method(\"#{name}?\") は、先ほどと一緒でシングルトンメソッドを定義している処理です{ !!public_send(name) } を見ていきますpublic_send がどんな処理をするか見てみると、引数のパブリックメソッドを呼び出す処理ですオブジェクトの public メソッド name を args を引数にして呼び出し、メソッ ドの実行結果を返します。1.public_send(:+, 2)  # => 3引用：Ruby 2.6.0 リファレンスマニュアルpublic_sendの前にある !! はdouble bangという方法で 戻り値を booleanにする方法です参照：Rubyの否定演算子2つ重ね「!!」（double-bang）でtrue/falseを返す｜TechRacho by BPS株式会社ちなみにrubocopではチェック対象になりますExamples:# bad!!something# good!something.nil?引用：Class: RuboCop::Cop::Style::DoubleNegation次の行をみますhoge な場合だと、 :@hoge となりますivar = \"@#{name}\".to_sym次の行をみますsingleton_class.silence_redefinition_of_method(\"#{name}=\")今までと同じようにこんどはsetterのメソッド定義していますまずは、次の処理の全体像をみます  define_singleton_method(\"#{name}=\") do |val|    redefine_singleton_method(name) { val }    if singleton_class?      class_eval do        redefine_method(name) do          if instance_variable_defined? ivar            instance_variable_get ivar          else            singleton_class.send name          end        end      end    end    val  enddefine_singleton_method(\"#{name}=\") は今までと同じでシングルトンメソッドの定義です次の行をみますredefine_singleton_method(name) { val }redefine_singleton_method は既に定義されているメソッドを上書きするRailsのメソッドです参照：Module次のif文内の全体像をみますif singleton_class?  class_eval do    redefine_method(name) do      if instance_variable_defined? ivar        instance_variable_get ivar      else        singleton_class.send name      end    end  endend最初の行は、レシーバがシングルトンのクラスかどうか判定していますif singleton_class?次の行をみますclass_eval do省略endclass_eval のブロック内の処理をレシーバに動的に実装しますモジュールのコンテキストで文字列 expr またはモジュール自身をブロックパラメータとするブロックを 評価してその結果を返します。モジュールのコンテキストで評価するとは、実行中そのモジュールが self になるということです。 つまり、そのモジュールの定義式の中にあるかのように実行されます。引用：Ruby 2.6.0 リファレンスマニュアル#class_evalclass_eval のブロック内を見ていきますredefine_method(name) do  if instance_variable_defined? ivar    instance_variable_get ivar  else    singleton_class.send name  endendredefine_method は activesupport > lib > active_support > core_ext > class > redefine_method.rb の17行目に定義されているメソッドで定義済みのメソッドを書き換える処理を行いますinstance_variable_defined? は引数のインスタンス変数名が定義されていれば、真を返すメソッドですインスタンス変数 var が定義されていたら真を返します。引用：Ruby 2.6.0 リファレンスマニュアル#instance_variable_defined?ivar は class_attribute メソッドの引数 *attrs の要素の1つになります  def class_attribute(    *attrs,    instance_accessor: true,    instance_reader: instance_accessor,    instance_writer: instance_accessor,    instance_predicate: true,    default: nil  )    attrs.each do |name|        省略          ivar = \"@#{name}\".to_symif instance_variable_defined? ivar が真の場合は、instance_variable_get ivar でレシーバのインスタンス変数を取り出しますオブジェクトのインスタンス変数の値を取得して返します。インスタンス変数が定義されていなければ nil を返します。引用：Ruby 2.6.0 リファレンスマニュアル#instance_variable_get偽の場合は、singleton_class.send name でレシーバから特異クラスを返し、特異クラスに対して send name で name メソッドを呼び出しますレシーバの特異クラスを返します。 まだ特異クラスがなければ、新しく作成します。レシーバが nil か true か false なら、それぞれ NilClass, TrueClass, FalseClass を返します。引用：Ruby 2.6.0 リファレンスマニュアル#singleton_class次にこちらをみますif instance_variable_defined?(ivar) が偽の場合に、 self.class.public_send name でレシーバのクラスメソッドを呼び出す処理になっている部分ですObject#public_send (Ruby 3.4 リファレンスマニュアル)  if instance_reader    redefine_method(name) do      if instance_variable_defined?(ivar)        instance_variable_get ivar      else        self.class.public_send name      end    end    redefine_method(\"#{name}?\") { !!public_send(name) } if instance_predicate  endif instance_predicate が真の場合は、レシーバのpublicなメソッドとして定義されている name を定義していますname が hoge である場合は、 hoge? というメソッドが定義され、 戻り値が true, false になります次をみていきますinstance_writer が真の場合に、redefine_method でセッターを定義しています  if instance_writer    redefine_method(\"#{name}=\") do |val|      instance_variable_set ivar, val    end  end参照：Object#instance_variable_set (Ruby 3.4 リファレンスマニュアル)読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/05/30/Rails_%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_class_attribute_%E7%B7%A8?utm_source=feed","isoDate":"2019-05-30T02:04:36.000Z","dateMiliSeconds":1559181876000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Macの開発環境構築が楽になるようにしてみました","contentSnippet":"Ansibleを使って、Macの開発環境構築出来るようにしましたhttps://github.com/shitake4/dev-environmentgithub.comAnsibleをインストールして$ ansible-playbook localhost.ymlで開発環境構築出来ます転職や新しいマシン買う度に、毎回開発環境を構築するのがちょっとしんどかったのと、PCの設定はなるべく共通化したいなと思ったので、やってみましたぜひ使ってみてください読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2019/03/09/Mac%E3%81%AE%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89%E3%81%8C%E6%A5%BD%E3%81%AB%E3%81%AA%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%97%E3%81%A6%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F?utm_source=feed","isoDate":"2019-03-09T01:20:27.000Z","dateMiliSeconds":1552094427000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Action Mailer Previewsをproduction環境で使えるようにする","contentSnippet":"Railsに搭載されているAction Mailerという機能でメールを送信することができるのですが、このメールの文面のプレビュー機能がAction Mailer Previewsです環境Ruby 2.4.2Ruby on Rails 4.2.8手順1. production環境でmailer_previewが閲覧できるように config/application.rb に設定の追加をしますconfig.action_mailer.preview_path = \"#{Rails.root}/lib/mailer_previews\"# production環境でもpreviewが可能にするconfig.action_mailer.show_previews = true2. ドメイン名/rails/mailers から管理画面のパス配下の ドメイン名/admin/rails/mailers になるようにしますconfig/initializers 配下にファイルを作成し、routes.rbへの追加処理を記述しますRails.application.config.after_initialize do |app|  app.routes.prepend do    get \"admin/rails/mailers\"         => \"rails/mailers#index\", internal: true    get \"admin/rails/mailers/*path\"   => \"rails/mailers#preview\", internal: true    get \"rails/mailers\"         => redirect('admin/rails/mailers')    get \"rails/mailers/*path\"   => redirect('admin/rails/mailers#preview')  endendこちらの記述はrails/railsを参照しましたgithub.com3. lib/mailer_previews/previews 配下にpreviewのクラスを作成しますy_yagiさんのブログが非常にわかりやすいです参照：RailsのAction Mailer Previewsについて | 日々雑記注意点これでproduction環境で domain/admin/rails/mailers にアクセスするとmailerを閲覧することが可能になりましたが、認証機能はないので、ユーザーも /admin/rails/mailers にアクセスすると閲覧出来てしまいます/admin を社内からのみアクセスできないようになど対策する必要があります","link":"https://blog.shitake4.tech/entry/2018/12/14/Action_Mailer_Previews%E3%82%92production%E7%92%B0%E5%A2%83%E3%81%A7%E4%BD%BF%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B?utm_source=feed","isoDate":"2018-12-14T01:26:24.000Z","dateMiliSeconds":1544750784000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support delegate_missing_to編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所delegate_missing_to を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますUserオブジェクトにないものをProfileにあるものにすべて委譲したいとしましょう。delegate_missing_toマクロを使えばこれを簡単に実装できます。class User < ApplicationRecord  has_one :profile   delegate_missing_to :profileendオブジェクト内にある呼び出し可能なもの（インスタンス変数、メソッド、定数など）なら何でも対象にできます。対象のうち、publicなメソッドだけが委譲されます。引用：RAILS GUIDES：delegate_missing_toソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def delegate_missing_to を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > module > delegation.rb# frozen_string_literal: truerequire \"set\"class Module省略def delegate_missing_to(target)    target = target.to_s    target = \"self.#{target}\" if DELEGATION_RESERVED_METHOD_NAMES.include?(target)    module_eval <<-RUBY, __FILE__, __LINE__ + 1      def respond_to_missing?(name, include_private = false)        # It may look like an oversight, but we deliberately do not pass        # +include_private+, because they do not get delegated.        #{target}.respond_to?(name) || super      end      def method_missing(method, *args, &block)        if #{target}.respond_to?(method)          #{target}.public_send(method, *args, &block)        else          begin            super          rescue NoMethodError            if #{target}.nil?              raise DelegationError, \"\\#{method} delegated to #{target}, but #{target} is nil\"            else              raise            end          end        end      end    RUBY  endendまずはここまで見ていきますdef delegate_missing_to(target)  target = target.to_s  target = \"self.#{target}\" if DELEGATION_RESERVED_METHOD_NAMES.include?(target)引数targetを文字列へ変換していますDELEGATION_RESERVED_METHOD_NAMES に含まれているのかチェックしています定数 DELEGATION_RESERVED_METHOD_NAMES がどのようなものか調べる為、記述箇所付近を見てみますclass Module  # Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+  # option is not used.  class DelegationError < NoMethodError; end  RUBY_RESERVED_KEYWORDS = %w(alias and BEGIN begin break case class def defined? do  else elsif END end ensure false for if in module next nil not or redo rescue retry  return self super then true undef unless until when while yield)  DELEGATION_RESERVED_KEYWORDS = %w(_ arg args block)  DELEGATION_RESERVED_METHOD_NAMES = Set.new(    RUBY_RESERVED_KEYWORDS + DELEGATION_RESERVED_KEYWORDS  ).freeze定義箇所はこちらですDELEGATION_RESERVED_METHOD_NAMES = Set.new(  RUBY_RESERVED_KEYWORDS + DELEGATION_RESERVED_KEYWORDS).freezeclass Set (Ruby 3.4 リファレンスマニュアル)は集合を表すクラスになりますSet.new で引数のオブジェクトを要素として集合を作りますSet.new に配列を与えるとSetの挙動このような集合を作成しますRUBY_RESERVED_KEYWORDS, DELEGATION_RESERVED_KEYWORDS で定義されている文字列を見てみるとRUBY_RESERVED_KEYWORDS = %w(alias and BEGIN begin break case class def defined? doelse elsif END end ensure false for if in module next nil not or redo rescue retryreturn self super then true undef unless until when while yield)DELEGATION_RESERVED_KEYWORDS = %w(_ arg args block)こちらの文字列に含まれているかをチェックしているようですここまでを踏まえてもう一度、こちらを見てみるとtarget = target.to_starget = \"self.#{target}\" if DELEGATION_RESERVED_METHOD_NAMES.include?(target)targetが含まれている場合は、self.target で自身のメソッドを呼び出しますそして次を見ていきますmodule_eval <<-RUBY, __FILE__, __LINE__ + 1  def respond_to_missing?(name, include_private = false)    # It may look like an oversight, but we deliberately do not pass    # +include_private+, because they do not get delegated.    #{target}.respond_to?(name) || super  end  def method_missing(method, *args, &block)    if #{target}.respond_to?(method)      #{target}.public_send(method, *args, &block)    else      begin        super      rescue NoMethodError        if #{target}.nil?          raise DelegationError, \"\\#{method} delegated to #{target}, but #{target} is nil\"        else          raise        end      end    end  endRUBYModule#class_eval (Ruby 3.4 リファレンスマニュアル)を使用して動的にメソッドを定義しています<<-RUBY 〜　RUBY に記載されている FILE , LINE は疑似変数というものですFILEフルパスとは限らないため、フルパスが必要な場合は File.expand_path(FILE) とする必要があります。LINERuby 2.5.0 リファレンスマニュアル#疑似変数動的に定義するメソッドを１つずつ見ていきますdef respond_to_missing?(name, include_private = false)  # It may look like an oversight, but we deliberately do not pass  # +include_private+, because they do not get delegated.  #{target}.respond_to?(name) || superend実際に動作する部分はこちらで#{target}.respond_to?(name) || supertargetにnameメソッドが存在するか、もしなければ、継承チェーン内の親の Object#respond_to_missing? (Ruby 3.4 リファレンスマニュアル)を実行します次にもうひとつ定義されるメソッドを見てみますdef method_missing(method, *args, &block)  if #{target}.respond_to?(method)    #{target}.public_send(method, *args, &block)  else    begin      super    rescue NoMethodError      if #{target}.nil?        raise DelegationError, \"\\#{method} delegated to #{target}, but #{target} is nil\"      else        raise      end    end  endendBasicObject#method_missing (Ruby 3.4 リファレンスマニュアル)はメタプログラミングで利用されるテクニックで、オーバーライドすることで、存在しないメソッドを呼び出したときに、エラーとなる前に特定の処理を実行することができますtargetのpublicなmethodに存在しているか確認しています Object#public_send (Ruby 3.4 リファレンスマニュアル)if #{target}.respond_to?(method)  #{target}.public_send(method, *args, &block)else句を見てみると、 NoMethodError が発生した場合、 targetがnilであれば、DelegationError とするようですelse  begin    super  rescue NoMethodError    if #{target}.nil?      raise DelegationError, \"\\#{method} delegated to #{target}, but #{target} is nil\"    else      raise    end  endendメタプログラミングについてはこちらの書籍がわかりやすかったので、もし読んでない方は読んでおくといいかもしれないですメタプログラミングRuby 第2版作者:Paolo PerrottaオライリージャパンAmazon読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/12/07/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_delegate_missing_to%E7%B7%A8?utm_source=feed","isoDate":"2018-12-07T02:32:53.000Z","dateMiliSeconds":1544149973000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support delegate編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所delegate を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますelegateマクロを使用すると、メソッドを簡単に委譲できます。あるアプリケーションのUserモデルにログイン情報があり、それに関連する名前などの情報はProfileモデルにあるとします。class User < ApplicationRecord  has_one :profileendこの構成では、user.profile.nameのようにプロファイル越しにユーザー名を取得することになります。これらの属性に直接アクセスできたらもっと便利になることでしょう。class User < ApplicationRecord  has_one :profile   def name    profile.name  endenddelegateを使用すればできるようになります。class User < ApplicationRecord  has_one :profile   delegate :name, to: :profileend引用：RAILS GUIDES：delegateソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def delegate を探してみます2. 該当箇所が10個ほどあったので、それぞれみてみます1. activesupport > lib > active_support > core_ext > module > delegation.rb# frozen_string_literal: truerequire \"set\"class Module  # Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+  # option is not used.省略def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil)    unless to      raise ArgumentError, \"Delegation needs a target. Supply an options hash with a :to key as the last argument (e.g. delegate :hello, to: :greeter).\"    end    if prefix == true && /^[^a-z_]/.match?(to)      raise ArgumentError, \"Can only automatically set the delegation prefix when delegating to a method.\"    end    method_prefix = \\      if prefix        \"#{prefix == true ? to : prefix}_\"      else        \"\"      end    location = caller_locations(1, 1).first    file, line = location.path, location.lineno    to = to.to_s    to = \"self.#{to}\" if DELEGATION_RESERVED_METHOD_NAMES.include?(to)    method_names = methods.map do |method|      # Attribute writer methods only accept one argument. Makes sure []=      # methods still accept two arguments.      definition = /[^\\]]=$/.match?(method) ? \"arg\" : \"*args, &block\"      # The following generated method calls the target exactly once, storing      # the returned value in a dummy variable.      #      # Reason is twofold: On one hand doing less calls is in general better.      # On the other hand it could be that the target has side-effects,      # whereas conceptually, from the user point of view, the delegator should      # be doing one call.      if allow_nil        method_def = [          \"def #{method_prefix}#{method}(#{definition})\",          \"_ = #{to}\",          \"if !_.nil? || nil.respond_to?(:#{method})\",          \"  _.#{method}(#{definition})\",          \"end\",        \"end\"        ].join \";\"      else        exception = %(raise DelegationError, \"#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \\#{self.inspect}\")        method_def = [          \"def #{method_prefix}#{method}(#{definition})\",          \" _ = #{to}\",          \"  _.#{method}(#{definition})\",          \"rescue NoMethodError => e\",          \"  if _.nil? && e.name == :#{method}\",          \"    #{exception}\",          \"  else\",          \"    raise\",          \"  end\",          \"end\"        ].join \";\"      end      module_eval(method_def, file, line)    end    private(*method_names) if private    method_names  endまずはじめにここまで見てみますunless to  raise ArgumentError, \"Delegation needs a target. Supply an options hash with a :to key as the last argument (e.g. delegate :hello, to: :greeter).\"endtoはdelegateメソッドの引数の為、引数toが偽の場合はArgumentErrorになるようにチェックしています次を見ていきますif prefix == true && /^[^a-z_]/.match?(to)  raise ArgumentError, \"Can only automatically set the delegation prefix when delegating to a method.\"endif文内の正規表現 /^[^a-z_]/ は、preifxがtrueかつ引数toの先頭の文字列が英字と_以外だった場合にマッチします※正規表現について忘れっぽい人のための正規表現チートシート #正規表現 - QiitaどのUNIXコマンドでも使える正規表現 #ShellScript - Qiita次にこちらを見ていきますmethod_prefix = \\  if prefix    \"#{prefix == true ? to : prefix}_\"  else    \"\"  endまず、こちらの書き方ですとif文内の戻り値が変数に格納されるという動きをします変数 = if 〜 else 〜 endこれを踏まえて見ていきます\"#{prefix == true ? to : prefix}_\"prefixがtrueの場合は、引数toに _ がついた文字列が戻り値になります_ がついた文字列が戻り値となりますprefixが偽の場合は、空文字が戻り値となります次を見ていきますlocation = caller_locations(1, 1).firstfile, line = location.path, location.linenocaller_locationsがわからなかったので調べてみます現在のフレームを Thread::Backtrace::Location の配列で返します。引 数で指定した値が範囲外の場合は nil を返します。引用：Ruby2.5.0リファレンスマニュアル#caller_locationsまだ、いまいち理解が進まないので、更に調べますKernel#caller_locationsスタックに積まれたメソッドの呼び出し元を配列として返してくれる。    1 def fiz  2   baz  3 end  4   5 def baz  6   p caller_locations  7 end  8   9 fiz% ruby caller_locations.rb[\"caller_locations.rb:2:in `fiz'\", \"caller_locations.rb:9:in `'\"]引用：Ruby 2.0の機能解説メモ（Kernel）メソッドの呼び出し元を調べる為に使うメソッドのようですlocation = caller_locations(1, 1).firstfile, line = location.path, location.lineno呼び出し元の情報を取得して、fileと行数をそれぞれ変数に格納しています次を見てみますto = to.to_sto = \"self.#{to}\" if DELEGATION_RESERVED_METHOD_NAMES.include?(to)引数toを文字列としていますif DELEGATION_RESERVED_METHOD_NAMES.include?(to)toがDELEGATION_RESERVED_METHOD_NAMES に含まれているかチェックしていますclass Module省略  RUBY_RESERVED_KEYWORDS = %w(alias and BEGIN begin break case class def defined? do  else elsif END end ensure false for if in module next nil not or redo rescue retry  return self super then true undef unless until when while yield)  DELEGATION_RESERVED_KEYWORDS = %w(_ arg args block)  DELEGATION_RESERVED_METHOD_NAMES = Set.new(    RUBY_RESERVED_KEYWORDS + DELEGATION_RESERVED_KEYWORDS  ).freezeこちらに該当する文字列であった場合は、レシーバのメソッドが呼ばれるという動きになります次の処理を見ていきますmethod_names = methods.map do |method|      # Attribute writer methods only accept one argument. Makes sure []=      # methods still accept two arguments.      definition = /[^\\]]=$/.match?(method) ? \"arg\" : \"*args, &block\"      # The following generated method calls the target exactly once, storing      # the returned value in a dummy variable.      #      # Reason is twofold: On one hand doing less calls is in general better.      # On the other hand it could be that the target has side-effects,      # whereas conceptually, from the user point of view, the delegator should      # be doing one call.      if allow_nil        method_def = [          \"def #{method_prefix}#{method}(#{definition})\",          \"_ = #{to}\",          \"if !_.nil? || nil.respond_to?(:#{method})\",          \"  _.#{method}(#{definition})\",          \"end\",        \"end\"        ].join \";\"      else        exception = %(raise DelegationError, \"#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \\#{self.inspect}\")        method_def = [          \"def #{method_prefix}#{method}(#{definition})\",          \" _ = #{to}\",          \"  _.#{method}(#{definition})\",          \"rescue NoMethodError => e\",          \"  if _.nil? && e.name == :#{method}\",          \"    #{exception}\",          \"  else\",          \"    raise\",          \"  end\",          \"end\"        ].join \";\"      end      module_eval(method_def, file, line)    endmethodsはdelegateメソッドの引数ですまず最初の処理を見ていきます# Attribute writer methods only accept one argument. Makes sure []=# methods still accept two arguments.definition = /[^\\]]=$/.match?(method) ? \"arg\" : \"*args, &block\"method名に]が含まれていないメソッドが確認しています次を見ていきます# The following generated method calls the target exactly once, storing# the returned value in a dummy variable.## Reason is twofold: On one hand doing less calls is in general better.# On the other hand it could be that the target has side-effects,# whereas conceptually, from the user point of view, the delegator should# be doing one call.if allow_nil  method_def = [    \"def #{method_prefix}#{method}(#{definition})\",    \"_ = #{to}\",    \"if !_.nil? || nil.respond_to?(:#{method})\",    \"  _.#{method}(#{definition})\",    \"end\",  \"end\"  ].join \";\"elseallow_nilが真の場合は、method_def変数に配列内の文字列を ; で連結し、文字列として格納していますまず配列の最初はメソッドの定義部分です\"def #{method_prefix}#{method}(#{definition})\",例えば、prefixがhogeの場合は、 def hoge_huga(arg) みたいになります次は、toをローカル変数 _ に格納しています\"_ = #{to}\",その次は、ローカル変数 _ がnilではないまたは、nilがmethodを実装している場合に真となります\"if !_.nil? || nil.respond_to?(:#{method})\",※ respond_to?についてObject#respond_to? (Ruby 3.4 リファレンスマニュアル)真だった場合には、変数 _ にメソッド定義部分で使用した変数 methodと仮引数で使用したdefinitionを使い呼び出しています\"  _.#{method}(#{definition})\"例えば、prefixがhoge, methodがhugaの場合は、このようなメソッド def hoge_huga(arg) を定義することになるのですが、内部での呼び出しは、このような形になります to.huga(arg)次に、こちらを見ていきますelse  exception = %(raise DelegationError, \"#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \\#{self.inspect}\")  method_def = [    \"def #{method_prefix}#{method}(#{definition})\",    \" _ = #{to}\",    \"  _.#{method}(#{definition})\",    \"rescue NoMethodError => e\",    \"  if _.nil? && e.name == :#{method}\",    \"    #{exception}\",    \"  else\",    \"    raise\",    \"  end\",    \"end\"  ].join \";\"endこちらはさきほどとの違いはエラー処理が追加されているところですNoMethodErrorが発生し、delegateメソッドの引数toがnilかつエラーが発生したメソッド名がmethodと同じであれば、delegationErrorが発生するという処理が先程と異なっています\"rescue NoMethodError => e\",\"  if _.nil? && e.name == :#{method}\",\"    #{exception}\",\"  else\",\"    raise\",\"  end\",これでmethod_def変数の戻り値の部分は見終わりました次を見ていくと、ファイルと行番号を指定して、メソッド定義を動的に行っていますmodule_eval(method_def, file, line)※ module_evalについてModule#class_eval (Ruby 3.4 リファレンスマニュアル)ブロック内は見終わったので、次を見ていきますprivate(*method_names) if privatemethod_namesdelegateメソッドの引数privateが真の場合は、method_namesで定義したメソッドをprivateに設定します※ privateについてModule#private (Ruby 3.4 リファレンスマニュアル)読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/11/07/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_delegate%E7%B7%A8?utm_source=feed","isoDate":"2018-11-07T01:48:21.000Z","dateMiliSeconds":1541555301000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support parents編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照くださいshitake4.hatenablog.com読んだ箇所parents を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますparentsメソッドは、レシーバに対してparentを呼び出し、Objectに到着するまでパスをさかのぼります。連鎖したモジュールは、階層の下から上の順に配列として返されます。module X  module Y    module Z    end  endendM = X::Y::Z X::Y::Z.parents # => [X::Y, X, Object]M.parents       # => [X::Y, X, Object]引用：RAILS GUIDES：parentsソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def parents を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > module > introspection.rb# frozen_string_literal: truerequire \"active_support/inflector\"class Module省略  # Returns all the parents of this module according to its name, ordered from  # nested outwards. The receiver is not contained within the result.  #  #   module M  #     module N  #     end  #   end  #   X = M::N  #  #   M.parents    # => [Object]  #   M::N.parents # => [M, Object]  #   X.parents    # => [M, Object]  def parents    parents = []    if parent_name      parts = parent_name.split(\"::\")      until parts.empty?        parents << ActiveSupport::Inflector.constantize(parts * \"::\")        parts.pop      end    end    parents << Object unless parents.include? Object    parents  endendまず、parents 変数を空の配列で初期化しています次に、if文内をみてみますif parent_name  parts = parent_name.split(\"::\")  until parts.empty?    parents << ActiveSupport::Inflector.constantize(parts * \"::\")    parts.pop  endend分岐条件はparent_nameメソッドの戻り値が真の場合に処理が実行されるようです※ parent_nameメソッドのコードリーディングについてはparentメソッドを読んだときに書きましたので、こちらを参照ください  ：Railsのソースコード読んでみる | Active Support parent編 - そういうこともあるparent_nameの戻り値は、親のモジュールの定数を戻り値としますX::Y::Z.parent_name # => \"X::Y\"M.parent_name       # => \"X::Y\"真になるパターンは親のモジュールがある場合ですさらに読み進めていきますparts = parent_name.split(\"::\") はparent_nameの戻り値の文字列を'::'を区切り文字として分割し、parts変数へ格納するという処理になります\"X::Y\".split(\"::\")=> ['X', 'Y']※ Ruby 2.5.0 リファレンスマニュアル#split次にunless内の処理をみていきますuntil parts.empty?  parents << ActiveSupport::Inflector.constantize(parts * \"::\")  parts.popenduntil parts.empty? でparts配列が空になるまでuntil … endを繰り返し処理を行っています※ Ruby 2.5.0 リファレンスマニュアル#untilRuby 2.5.0 リファレンスマニュアル#emptyuntil内の処理をみてみますparents << ActiveSupport::Inflector.constantize(parts * \"::\")parts.popconstantizeメソッドの引数 parts * \"::\" ですが、配列partsの文字列要素の間に\"::\"を連結し、文字列を生成していますArry#* を調べてみるとself * sep -> String[permalink][rdoc]指定された sep を間にはさんで連結した文字列を生成して返します。Array#join(sep) と同じ動作をします。[PARAM] sep:文字列を指定します。 文字列以外のオブジェクトを指定した場合は to_str メソッドによる暗黙の型変換を試みます。p [1,2,3] * \",\"# => \"1,2,3\"引用：Ruby 2.5.0 リファレンスマニュアル#Array*ActiveSupport::Inflector.constantizeは引数の文字列を定数に変換します※ constantizeメソッドのコードリーディングについては、こちらを参照ください：Railsのソースコード読んでみる | Active Support constantize編 - そういうこともあるそしてその戻り値をメソッドの最初行で初期化した変数に入れていますparents << ActiveSupport::Inflector.constantize(parts * \"::\")そして parts.pop で配列の末尾の要素を取り除いています※ Ruby 2.5.0 リファレンスマニュアル#popここまでuntil、if文の処理が読み終わりました最後にparents変数にObjectが含まれているか確認し、なかった場合はObjectを追加していますparents << Object unless parents.include? Objectparents     読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/09/21/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_parents%E7%B7%A8?utm_source=feed","isoDate":"2018-09-21T03:58:55.000Z","dateMiliSeconds":1537502335000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"AnsibleでサーバにRubyをインストールする手順をまとめました","contentSnippet":"Amazon Linux2にAnsibleを使ってRubyをインストールする手順をまとめてみましたqiita.com読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/09/13/Ansible%E3%81%A7%E3%82%B5%E3%83%BC%E3%83%90%E3%81%ABRuby%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B%E6%89%8B%E9%A0%86%E3%82%92%E3%81%BE%E3%81%A8%E3%82%81%E3%81%BE?utm_source=feed","isoDate":"2018-09-13T01:04:06.000Z","dateMiliSeconds":1536800646000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support constantize編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所constantize を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます説明引数の文字列で指定した名前で定数を探す使い方文字列.constantize()例'Module'.constantize     # => Module'Test::Unit'.constantize # => Test::Unit引用：Railsドキュメント：constantizeソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def constantize を探してみます2. 該当箇所が2箇所ほどあったので、それぞれみてみます1. activesupport > lib > active_support > core_ext > string > inflections.rb# frozen_string_literal: truerequire \"active_support/inflector/methods\"require \"active_support/inflector/transliterate\"# String inflections define new methods on the String class to transform names for different purposes.# For instance, you can figure out the name of a table from the name of a class.##   'ScaleScore'.tableize # => \"scale_scores\"#class String省略  # +constantize+ tries to find a declared constant with the name specified  # in the string. It raises a NameError when the name is not in CamelCase  # or is not initialized.  See ActiveSupport::Inflector.constantize  #  #   'Module'.constantize  # => Module  #   'Class'.constantize   # => Class  #   'blargle'.constantize # => NameError: wrong constant name blargle  def constantize    ActiveSupport::Inflector.constantize(self)  end省略String クラスをオープンクラスして constantizeメソッドを実装しています処理は ActiveSupport::Inflector.constantize へ移譲しているので、こちらをみてみます2. activesupport > lib > active_support > inflector > methods.rb# Tries to find a constant with the name specified in the argument string.    #    #   constantize('Module')   # => Module    #   constantize('Foo::Bar') # => Foo::Bar    #    # The name is assumed to be the one of a top-level constant, no matter    # whether it starts with \"::\" or not. No lexical context is taken into    # account:    #    #   C = 'outside'    #   module M    #     C = 'inside'    #     C                # => 'inside'    #     constantize('C') # => 'outside', same as ::C    #   end    #    # NameError is raised when the name is not in CamelCase or the constant is    # unknown.    def constantize(camel_cased_word)      names = camel_cased_word.split(\"::\".freeze)      # Trigger a built-in NameError exception including the ill-formed constant in the message.      Object.const_get(camel_cased_word) if names.empty?      # Remove the first blank element in case of '::ClassName' notation.      names.shift if names.size > 1 && names.first.empty?      names.inject(Object) do |constant, name|        if constant == Object          constant.const_get(name)        else          candidate = constant.const_get(name)          next candidate if constant.const_defined?(name, false)          next candidate unless Object.const_defined?(name)          # Go down the ancestors to check if it is owned directly. The check          # stops when we reach Object or the end of ancestors tree.          constant = constant.ancestors.inject(constant) do |const, ancestor|            break const    if ancestor == Object            break ancestor if ancestor.const_defined?(name, false)            const          end          # owner is in Object, so raise          constant.const_get(name, false)        end      end    end省略freeze で文字列 ::　を変更不可のオブジェクトとし、引数camel_cased_word を :: でsplitしています※ splitの仕様はこちらString#split (Ruby 3.4 リファレンスマニュアル)次にこちらをみてみます# Trigger a built-in NameError exception including the ill-formed constant in the message.Object.const_get(camel_cased_word) if names.empty?引数をsplitした配列の要素が0のときに実行される処理です※ Array#empty?の仕様はこちらArray#empty? (Ruby 3.4 リファレンスマニュアル)Object.const_get を調べてみますname で指定される名前の定数の値を取り出します。Module#const_defined? と違って Object を特別扱いすることはありません。[PARAM] name:定数名。String か Symbol で指定します。 完全修飾名を指定しなかった場合はモジュールに定義されている name で指定される名前の定数の値を取り出します。[PARAM] inherit:false を指定するとスーパークラスや include したモジュールで 定義された定数は対象にはなりません。[EXCEPTION] NameError:定数が定義されていないときに発生します。module Bar  BAR = 1endclass Object  include Barend# Object では include されたモジュールに定義された定数を見付けるp Object.const_get(:BAR)   # => 1class Baz  include Barend# Object以外でも同様p Baz.const_get(:BAR)      # => 1# 定義されていない定数p Baz.const_get(:NOT_DEFINED) #=> raise NameError# 第二引数に false を指定すると自分自身に定義された定数から探すp Baz.const_get(:BAR, false) #=> raise NameError# 完全修飾名を指定すると include や自分自身へ定義されていない場合でも参照できるp Class.const_get(\"Bar::BAR\") # => 1引用：Ruby 2.5.0 リファレンスマニュアル#const_getnameで指定されている名前の定数を取り出す処理で、完全修飾名であれば、自分へ定義されていない場合でも参照できる処理になりますcamel_cased_word が間違った名称だった場合に、NameErrorを発生させる為に使用しているようですプルリクエストはこちらですFix #10932. Treat \"\" and \"::\" as invalid on constantize by killthekitten · Pull Request #10943 · rails/rails · GitHub次にこちらを読みます# Remove the first blank element in case of '::ClassName' notation.names.shift if names.size > 1 && names.first.empty?こちらの処理はさきほどのコミットで追加されています::ClassNameをsplitするケースだと配列の先頭が空になる為、先頭の要素を取り除く処理を実行しています※ Array#shiftの仕様はこちらArray#shift (Ruby 3.4 リファレンスマニュアル)次にこちらをみていきますnames.inject(Object) do |constant, name|    if constant == Object        constant.const_get(name)    else        candidate = constant.const_get(name)        next candidate if constant.const_defined?(name, false)        next candidate unless Object.const_defined?(name)        # Go down the ancestors to check if it is owned directly. The check        # stops when we reach Object or the end of ancestors tree.        constant = constant.ancestors.inject(constant) do |const, ancestor|        break const    if ancestor == Object        break ancestor if ancestor.const_defined?(name, false)        const        end        # owner is in Object, so raise        constant.const_get(name, false)    endendまず inject の仕様を調べますリストのたたみこみ演算を行います。最初に初期値 init と self の最初の要素を引数にブロックを実行します。 2 回目以降のループでは、前のブロックの実行結果と self の次の要素を引数に順次ブロックを実行します。 そうして最後の要素まで繰り返し、最後のブロックの実行結果を返します。要素が存在しない場合は init を返します。初期値 init を省略した場合は、 最初に先頭の要素と 2 番目の要素をブロックに渡します。 また要素が 1 つしかなければブロックを実行せずに最初の要素を返します。 要素がなければブロックを実行せずに nil を返します。[PARAM] init:最初の result の値です。任意のオブジェクトが渡せます。[PARAM] sym:ブロックの代わりに使われるメソッド名を表す Symbol オブジェクトを指定します。 実行結果に対して sym という名前のメソッドが呼ばれます。例:# 合計を計算する。p [2, 3, 4, 5].inject {|result, item| result + item }        #=> 14# 自乗和を計算する。初期値をセットする必要がある。p [2, 3, 4, 5].inject(0) {|result, item| result + item**2 }  #=> 54この式は以下のように書いても同じ結果が得られます。result = 0[1, 2, 3, 4, 5].each {|v| result += v }p result   # => 15p [1, 2, 3, 4, 5].inject(:+)                    #=> 15p [\"b\", \"c\", \"d\"].inject(\"abbccddde\", :squeeze) #=> \"abcde\"引用：Ruby 2.5.0 リファレンスマニュアル#injectinjectで初期化した値が、ブロックの最初の要素 constant となり、配列 names がブロックの2番目の要素 name に入るという感じになりますnames.inject(Object) do |constant, name|ブロックの内部の処理をみてみますif constant == Object    constant.const_get(name)elseブロックの引数 constant がObjectクラスである場合、.const_get で nameで指定されている名前の定数を取り出す処理を行っていますconstant.const_get(name) の戻り値がconstantとして扱われます次にelse以降をみていきますelse    candidate = constant.const_get(name)    next candidate if constant.const_defined?(name, false)candidate変数にnameで指定されている名前の変数を取り出しておりますconst_defined? の処理を調べてみるとモジュールに name で指定される名前の定数が定義されている時真 を返します。スーパークラスや include したモジュールで定義された定数を検索対象 にするかどうかは第二引数で制御することができます。[PARAM] name:String, Symbol で指定される定数名。[PARAM] inherit:false を指定するとスーパークラスや include したモジュールで 定義された定数は対象にはなりません。module Kernel  FOO = 1end# Object は include したモジュールの定数に対しても# true を返すp Object.const_defined?(:FOO)   # => truemodule Bar  BAR = 1endclass Object  include Barend# ユーザ定義のモジュールに対しても同様p Object.const_defined?(:BAR)   # => trueclass Baz  include Barend# Object 以外でも同様になった# 第二引数のデフォルト値が true であるためp Baz.const_defined?(:BAR)      # => true# 第二引数を false にした場合p Baz.const_defined?(:BAR, false)   # => false引用：Ruby 2.5.0 リファレンスマニュアル#const_defined?constantに定義されている名前か確認している処理のようです。更に第二引数がfalseの為、スーパークラスや includeしたモジュールに定義された定数は対象外としています次の行をみてみますnext candidate unless Object.const_defined?(name)Objectクラスに定義された定数名でない場合には、candidateをそのまま戻り値として次のループとなっています次をみてみるとinject内でさらにinjectしている処理があります# Go down the ancestors to check if it is owned directly. The check# stops when we reach Object or the end of ancestors tree.constant = constant.ancestors.inject(constant) do |const, ancestor|    break const    if ancestor == Object    break ancestor if ancestor.const_defined?(name, false)    constend省略継承チェーンの親要素までみて確認する処理のようですconstantはObjectクラスではないconstantオブジェクト自身に定義されている定数ではない（includeしているクラス, スーパークラスの定数は対象外）constantオブジェクトはObjectクラスに定義されている定数（Objectにincludeしているクラス, スーパークラスの定数も対象）となっていますまず、ancestors メソッドを調べてみますクラス、モジュールのスーパークラスとインクルードしているモジュール を優先順位順に配列に格納して返します。module Fooendclass Bar  include Fooendclass Baz < Bar  p ancestors  p included_modules  p superclassend# => [Baz, Bar, Foo, Object, Kernel, BasicObject]# => [Foo, Kernel]# => Bar引用：Ruby 2.5.0 リファレンスマニュアル#ancestorsconstant.ancestors ではconstant変数のオブジェクトの継承チェーンを取り出しています次にブロックの中をみてみますbreak const    if ancestor == Objectbreak ancestor if ancestor.const_defined?(name, false)const継承チェーン内にObjectが含まれている場合は、constを戻り値とし、ループを終了しています次の行をを見ると継承チェーンのオブジェクトancestorに定義された定数であった場合は、そのオブジェクトを戻り値とし、ループを終了しますどの条件にもひっかからない場合は、更に継承チェーンをさかのぼって調べます次をみていきます# owner is in Object, so raiseconstant.const_get(name, false)さきほどの処理で取り出したconstantから定数を取り出しています読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/09/06/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_constantize%E7%B7%A8?utm_source=feed","isoDate":"2018-09-06T02:37:10.000Z","dateMiliSeconds":1536201430000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support parent編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所parent を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますparentメソッドは、名前がネストしたモジュールに対して実行でき、対応する定数を持つモジュールを返します。module X  module Y    module Z    end  endendM = X::Y::Z X::Y::Z.parent_name # => \"X::Y\"M.parent_name       # => \"X::Y\"引用：RAILS GUIDES：parentソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def parent を探してみます2. 該当箇所が1箇所だったので、みてみます1. activesupport > lib > active_support > core_ext > module > introspection.rb# Returns the module which contains this one according to its name.  #  #   module M  #     module N  #     end  #   end  #   X = M::N  #  #   M::N.parent # => M  #   X.parent    # => M  #  # The parent of top-level and anonymous modules is Object.  #  #   M.parent          # => Object  #   Module.new.parent # => Object  def parent    parent_name ? ActiveSupport::Inflector.constantize(parent_name) : Object  end省略三項演算子 xxx ? yyy : zzz を使っていますparent_name の戻り値によって、ActiveSupport::Inflector.constantize(parent_name) Objectparent_name の実装をみてみます# frozen_string_literal: truerequire \"active_support/inflector\"class Module  # Returns the name of the module containing this one.  #  #   M::N.parent_name # => \"M\"  def parent_name    if defined?(@parent_name)      @parent_name    else      parent_name = name =~ /::[^:]+\\Z/ ? $`.freeze : nil      @parent_name = parent_name unless frozen?      parent_name    end  end省略Moduleクラスをオープンクラスし、parent_name メソッドを実装していますまずは最初のif文をみてみるとif defined?(@parent_name)  @parent_nameelse変数@parent_nameが定義されている場合はそのまま変数を戻り値としますelse  parent_name = name =~ /::[^:]+\\Z/ ? $`.freeze : nil  @parent_name = parent_name unless frozen?  parent_nameendこちらからみていきますname =~ /::[^:]+\\Z/Moduleクラスのnameメソッドの仕様を調べてみるとモジュールやクラスの名前を文字列で返します。このメソッドが返す「モジュール / クラスの名前」とは、 より正確には「クラスパス」を指します。 クラスパスとは、ネストしているモジュールすべてを 「::」を使って表示した名前のことです。 クラスパスの例としては「CGI::Session」「Net::HTTP」が挙げられます。[RETURN]名前のないモジュール / クラスに対しては nil を返します。module A  module B  end  p B.name  #=> \"A::B\"  class C  endendp A.name    #=> \"A\"p A::B.name #=> \"A::B\"p A::C.name #=> \"A::C\"# 名前のないモジュール / クラスp Module.new.name   #=> nilp Class.new.name    #=> nil引用：Ruby 2.5.0 リファレンスマニュアル#nameクラスパスを戻り値をするメソッドのようです=~ も調べてみます正規表現 other とのマッチを行います。 マッチが成功すればマッチした位置のインデックスを、そうでなければ nil を返します。other が正規表現でも文字列でもない場合は other =~ self を行います。このメソッドが実行されると、組み込み変数 $~, $1, ... にマッチに関する情報が設定されます。[PARAM] other:正規表現もしくは =~ メソッドを持つオブジェクト[EXCEPTION] TypeError:other が文字列の場合に発生します。例p \"string\" =~ /str/   # => 0p \"string\" =~ /not/   # => nilp \"abcfoo\" =~ /foo/   # => 3引用：Ruby 2.5.0 リファレンスマニュアル#=~正規表現にパターンマッチした情報を$1などに格納する処理でマッチした場合は、Integerクラスが戻り値となるようです正規表現をみてみると ::[^:]+\\Z/::ではじまり[^:]+ :にマッチしない1回以上の繰り返しを末尾とする文字にマッチするようです三項演算子の真の場合の処理 $`.freeze をみてみます現在のスコープで最後に成功した正規表現のパターンマッチでマッチした 部分より後ろの文字列です。 最後のマッチが失敗していた場合には nil となります。Regexp.last_match.post_match と同じです。この変数はローカルスコープかつスレッドローカル、読み取り専用です。 Ruby起動時の初期値は nil です。例str = '<p><a href=\"http://example.com\">example.com</a></p>'if %r[<a href=\"(.*?)\">(.*?)</a>] =~ str  p $'end#=> \"</p>\"引用：Ruby 2.5.0 リファレンスマニュアル#variable $'パターンマッチした部分より、後ろの文字列を戻り値とし、それを.freeze で変更不可としていますここまでの処理をサンプルのクラスで実行し、動きをみてみました次に @parent_name = parent_name unless frozen? をみますfrozen? でレシーバが変更不可状態がチェックしていますこちらのコミットが該当のコミットとイシューのようですプルリクエストgithub.comイシューgithub.comイシューをみてみるとオブジェクトをfreezeした状態でインスタンス変数に変更を加えてしまうとエラーとなる為、回避しているようですfrozen? をしている理由がわかったので、 unless の条件文内部の処理をみてみます@parent_name = parent_name こちらの処理でインスタンス変数@parent_nameににいれることでキャッシュとして扱えるようにしていますparent_name メソッドを呼ぶと 一度目の処理でインスタンス変数は初期化済みの為、if defined?(@parent_name) がtrueとなるので、else以降の処理は呼ばれず、インスタンス変数を返す処理になりますparent_nameメソッドの処理は読めたので、 parent メソッドに戻ります# Returns the module which contains this one according to its name.  #  #   module M  #     module N  #     end  #   end  #   X = M::N  #  #   M::N.parent # => M  #   X.parent    # => M  #  # The parent of top-level and anonymous modules is Object.  #  #   M.parent          # => Object  #   Module.new.parent # => Object  def parent    parent_name ? ActiveSupport::Inflector.constantize(parent_name) : Object  end省略parent_nameの戻り値が真だった場合をみてみますActiveSupport::Inflector.constantizeを調べるとTries to find a constant with the name specified in the argument string.constantize('Module')   # => Moduleconstantize('Foo::Bar') # => Foo::BarThe name is assumed to be the one of a top-level constant, no matter whether it starts with “::” or not. No lexical context is taken into account:C = 'outside'module M  C = 'inside'  C                # => 'inside'  constantize('C') # => 'outside', same as ::Cend引用：Ruby on Rails 5.2.1#ActiveSupport::Inflector#constantize引数で指定した名前の定数を探すメソッドのようです<追記>blog.shitake4.techなので、ActiveSupport::Inflector.constantize(parent_name) は parent_nameの戻り値の定数を返します読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/09/05/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_parent%E7%B7%A8?utm_source=feed","isoDate":"2018-09-05T02:31:41.000Z","dateMiliSeconds":1536114701000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのコミットでわからないものを調べてみた | rails commit log流し読みを読んでみた","contentSnippet":"1. 概要日課で@y_yagiさんのrails commit log流し読みを読んでいるのですが、コミットの内容を読んでみて、どうしてその修正でバグが直るのかわからないものがありましたこちらですissuegithub.com該当PRgithub.com修正内容を抜粋2. PRを理解するためにやってみたこと1. まず、PRのコメントを読んでみるFix merging relation that order including `?`The `Relation::Merger` has a problem that order values would be mergedas nested array.That was caused an issue #33664 since if array value is passed to`order` and first element in the array includes `?`, the array isregarded as a prepared statement and bind variables.https://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_for_orderJust merging that as splat args like other values would fix the issue.Fixes #33664.ネストしたArrayで最初の値に'?'が含まれている場合、prepared statementとみなされてエラーとなるというバグとのことでしたissueには再現コードも書かれていましたgithub.comどういったバグになるのかが何となく理解できたところで、コードを追ってみます2. 変数の前に*をつけるとどんな動きなのか調べてみる修正の対象になった箇所はこちらです        def merge_multi_values          if other.reordering_value            # override any order specified in the original relation            relation.reorder!(*other.order_values)          elsif other.order_values.any?            # merge in order_values from relation            relation.order!(*other.order_values)          end          extensions = other.extensions - relation.extensions          relation.extending!(*extensions) if extensions.any?        endRuby * 等でGoogleで調べてみると、こちらの記事がヒットしたので、読んでみましたhttps://alpaca.tc/blog/ruby/how-to-use-star.html alpaca.tc変数の前に* を書くと、配列に変換してくれるようです3. relation.reorder! を読んでみるrails/activerecord/lib/active_record/relation/query_methods.rb# Same as #reorder but operates on relation in-place instead of copying.def reorder!(*args) # :nodoc:  preprocess_order_args(args)  self.reordering_value = true  self.order_values = args  selfendreorder! の引数をそのまま preprocess_order_argsに渡しているので、こちらの処理を追ってみます4. preprocess_order_args を読むrails/activerecord/lib/active_record/relation/query_methods.rbdef preprocess_order_args(order_args)  order_args.map! do |arg|    klass.sanitize_sql_for_order(arg)  end  order_args.flatten!  @klass.enforce_raw_sql_whitelist(    order_args.flat_map { |a| a.is_a?(Hash) ? a.keys : a },    whitelist: AttributeMethods::ClassMethods::COLUMN_NAME_ORDER_WHITELIST  )省略end引数を.map! して 配列の要素を sanitize_sql_for_order に渡しているようなので、こちらを読んでみます5. sanitize_sql_for_order を読むPRのコメントに書いてあったエラーの原因のメソッドまでいきつきましたThat was caused an issue #33664 since if array value is passed toorder and first element in the array includes ?, the array isregarded as a prepared statement and bind variables.https://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_for_orderこちらのドキュメントを読んで、挙動を確認してみますsanitize_sql_for_order(condition)Accepts an array, or string of SQL conditions and sanitizes them into a valid SQL fragment for an ORDER clause.sanitize_sql_for_order(condition)sanitize_sql_for_order([\"field(id, ?)\", [1,3,2]])# => \"field(id, 1,3,2)\"sanitize_sql_for_order(\"id ASC\")# => \"id ASC\"引用：Ruby on Rails 5.2.1#sanitize_sql_for_orderそしてコードを読んでみると、rails/activerecord/lib/active_record/sanitization.rbdef sanitize_sql_for_order(condition)  if condition.is_a?(Array) && condition.first.to_s.include?(\"?\")    enforce_raw_sql_whitelist([condition.first],      whitelist: AttributeMethods::ClassMethods::COLUMN_NAME_ORDER_WHITELIST    )    # Ensure we aren't dealing with a subclass of String that might    # override methods we use (eg. Arel::Nodes::SqlLiteral).    if condition.first.kind_of?(String) && !condition.first.instance_of?(String)      condition = [String.new(condition.first), *condition[1..-1]]    end    Arel.sql(sanitize_sql_array(condition))  else    condition  endendconditionが配列かつ要素の最初の値に'?'が含まれている場合に、prepared statementと判断し、処理をやってくれるみたいですなので、ここまで読んでみて推測すると、正しい挙動では引数conditionはこちらの条件 if condition.is_a?(Array) && condition.first.to_s.include?(\"?\")には該当せず、else  conditionendこちらになるのが正しい挙動のようですここまで読んでみて仮設を立てるとpreprocess_order_args(order_args) の引数がバグのケースだと [['?', '!']] が引数となり、正しいケースだと ['?', '!']となるのではないかなと思いましたしかしなぜこちらのパターン[['?', '!']]　になるのかわからず困っていたのですが、会社の先輩に相談したところこちらの記事を教えていただきましたqiita.com変数の前に* を書くと、配列に変換してくれるではなく、可変長引数を受け取るメソッドに、配列を渡す際に変数に* をつけないともう一回り配列で包まれてしまうというこちらの挙動ではないかとのことでしたなので、こちらの修正を行うことでother.order_values の戻り値の配列がさらにもうひと回り配列で包まれることが無くなるということだと思われます6. other.order_values の戻り値を確認してみるorder_valuesの定義箇所を探してみようと思い def other.order_values でgrepしてみてもヒットしませんでしたactiverecord/lib/active_record/relation/merger.rb ファイルの中を見てみると、lock_value, create_with_valueなどのメソッドがあり、こちらも定義箇所が見つからなかったので、define_method などでsuffixに_valueを設定し、動的にメソッド定義しているのではないかと予想し探し方を変えてみましたMerger クラス内で other を初期化している箇所を探してみると(RubyMineで⌘+B)こちらにいきつきましたactiverecord/lib/active_record/relation/merger.rbclass Merger # :nodoc:      attr_reader :relation, :values, :other      def initialize(relation, other)        @relation = relation        @values   = other.values        @other    = other      end省略Mergeクラスを初期化する際に引数でotherを入れているので、初期化処理の箇所がないか調べてみましたこちらを見てみるとotherはRelationクラスの可能性がありそうですrails/activerecord/lib/active_record/relation/spawn_methods.rbdef merge!(other) # :nodoc:      if other.is_a?(Hash)        Relation::HashMerger.new(self, other).merge      elsif other.is_a?(Relation)        Relation::Merger.new(self, other).merge      elsif other.respond_to?(:to_proc)        instance_exec(&other)      else        raise ArgumentError, \"#{other.inspect} is not an ActiveRecord::Relation\"      end    end省略こちらのファイルを見てみると、activerecord/lib/active_record/relation.rb# frozen_string_literal: truemodule ActiveRecord  # = Active Record \\Relation  class Relation    MULTI_VALUE_METHODS  = [:includes, :eager_load, :preload, :select, :group,                            :order, :joins, :left_outer_joins, :references,                            :extending, :unscope]    SINGLE_VALUE_METHODS = [:limit, :offset, :lock, :readonly, :reordering,                            :reverse_order, :distinct, :create_with, :skip_query_cache]    CLAUSE_METHODS = [:where, :having, :from]    INVALID_METHODS_FOR_DELETE_ALL = [:distinct, :group, :having]    VALUE_METHODS = MULTI_VALUE_METHODS + SINGLE_VALUE_METHODS + CLAUSE_METHODS    include Enumerable    include FinderMethods, Calculations, SpawnMethods, QueryMethods, Batches, Explain, Delegation定数の中にorder とあるので、この定数を利用してメソッド定義しているのではないかと予想しましたMULTI_VALUE_METHODS で検索するとこちらでしか利用してなさそうなので、 ruby VALUE_METHODS = MULTI_VALUE_METHODS + SINGLE_VALUE_METHODS + CLAUSE_METHODSactiverecord/lib/active_record配下で、 VALUE_METHODSを使用しているところを探してみますこちらで定義していましたrails/activerecord/lib/active_record/relation/query_methods.rbRelation::VALUE_METHODS.each do |name|      method_name = \\        case name        when *Relation::MULTI_VALUE_METHODS then \"#{name}_values\"        when *Relation::SINGLE_VALUE_METHODS then \"#{name}_value\"        when *Relation::CLAUSE_METHODS then \"#{name}_clause\"        end      class_eval <<-CODE, __FILE__, __LINE__ + 1        def #{method_name}                   # def includes_values          get_value(#{name.inspect})         #   get_value(:includes)        end                                  # end        def #{method_name}=(value)           # def includes_values=(value)          set_value(#{name.inspect}, value)  #   set_value(:includes, value)        end                                  # end      CODE    end省略動的にメソッドを定義し、メソッド内部では get_value を呼び出しているので、こちらの定義箇所を読んでみます    # Returns a relation value with a given name    def get_value(name) # :nodoc:      @values.fetch(name, DEFAULT_VALUES[name])    endfetchの第二引数を指定すると、キーが存在しない場合、デフォルト値を返すようになっているので、DEFAULT_VALUES を探してみますDEFAULT_VALUES ハッシュにはorderが定義されていないのですが      DEFAULT_VALUES = {        create_with: FROZEN_EMPTY_HASH,        where: Relation::WhereClause.empty,        having: Relation::WhereClause.empty,        from: Relation::FromClause.empty      }      Relation::MULTI_VALUE_METHODS.each do |value|        DEFAULT_VALUES[value] ||= FROZEN_EMPTY_ARRAY      endこちらで追加していました      Relation::MULTI_VALUE_METHODS.each do |value|        DEFAULT_VALUES[value] ||= FROZEN_EMPTY_ARRAY      end配列をループしている内部の処理は、左辺が未定義または偽の場合に右辺の値を代入するという意味になりますRubyの||=というイディオムは左辺が未定義または偽なら代入の意味 -- ぺけみさおなので配列の要素のこちらをひとつずつ取り出しながら    MULTI_VALUE_METHODS  = [:includes, :eager_load, :preload, :select, :group,                            :order, :joins, :left_outer_joins, :references,                            :extending, :unscope]未定義の場合は、FROZEN_EMPTY_ARRAYを追加していくという処理です DEFAULT_VALUES[value] ||= FROZEN_EMPTY_ARRAYFROZEN_EMPTY_ARRAYは空の配列になります    FROZEN_EMPTY_ARRAY = [].freezeなので、other.order_values の戻り値は配列になるということでした今回のPRの修正、reoader! メソッドの引数に * をつけることで配列で包まれることなく、配列を渡せるようになったというのが修正内容でした読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/08/23/Rails%E3%81%AE%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%82%82%E3%81%AE%E3%82%92%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F_%7C_rails_commit_log?utm_source=feed","isoDate":"2018-08-23T02:36:43.000Z","dateMiliSeconds":1534991803000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Ansibleでalbに動的にEC2インスタンスを追加する","contentSnippet":"最近Ansibleを使ってAWSの環境構築をしており、タイトルの通りのことをやりたかったのですが、かなりハマってしまった為、自分へのメモも兼ねて書きますやりたかったことこちらの図のようにパブリックサブネットのALBにプライベートサブネットのEC2インスタンスを接続するみたいな作りでEC2インスタンスの台数を増やしても勝手に追加してくれるようにしたかったpublicサブネットにalbを置き、privateサブネットのec2インスタンスにバランシングするという構成ですうまくいかなかったやりかたAnsibleモジュールのこの3つを使って、やろうとしていました1. ec2- name: Set up about EC2 instance for Web  ec2:    aws_access_key: \"{{aws_access_key}}\"    aws_secret_key: \"{{aws_secret_key}}\"    region: \"{{region}}\"    group: default    image: ami-e99f4896    instance_tags:      Name: web    instance_type: t2.micro    monitoring: yes    vpc_subnet_id: \"{{private_subnet_az_c.subnet.id}}\"    exact_count: 2    count_tag:      Name: web    wait: yes  register: ec2_web- debug: var=ec2_web2. elb_target_group- name: Set up about elb target Group  elb_target_group:    aws_access_key: \"{{aws_access_key}}\"    aws_secret_key: \"{{aws_secret_key}}\"    region: \"{{region}}\"    health_check_protocol: http    name: web-ec2-instances    protocol: http    port: 80    state: present    stickiness_enabled: yes    targets:      - Id: \"{{ item.id }}\"      - Port: 80    vpc_id: '{{vpc.vpcs | map(attribute=\"id\") | first }}'  with_items: \"{{ ec2_web.tagged_instances }}\"  register: elb_target_group- debug: var=elb_target_group3. elb_application_lb- name: Set up about Application Load Balancer  elb_application_lb:    aws_access_key: \"{{aws_access_key}}\"    aws_secret_key: \"{{aws_secret_key}}\"    region: \"{{region}}\"    name: alb_for_web_ec2_instance    state: present    subnets:      - \"{{public_subnet_az_a.subnet}}\"    listeners:      - Protocol: HTTP        Port: 80        DefaultActions:          - Type: forward            TargetGroupName: web-ec2-instancesこれで実行すると、elb_target_groupのtargetsがうまく設定されませんとなり、結果はalbに1台だけ設定されているという状態でしたうまくいった方法EC2のインスタンスの1台ごとに名前を付け、targetsに設定しました1. elb_target_group- name: Set up about elb target Group  elb_target_group:    aws_access_key: \"{{aws_access_key}}\"    aws_secret_key: \"{{aws_secret_key}}\"    region: \"{{region}}\"    health_check_protocol: http    name: web-ec2-instances    protocol: http    port: 80    state: present    stickiness_enabled: yes    targets:      - Id: \"{{ ec2_web1.tagged_instances | map(attribute='id') | first }}\"      - Id: \"{{ ec2_web2.tagged_instances | map(attribute='id') | first }}\"    vpc_id: '{{vpc.vpcs | map(attribute=\"id\") | first }}'  register: elb_target_group- debug: var=elb_target_groupまとめAnsibleドキュメントはしっかりと読んで別モジュールを探せば解決法はあるという当たり前すぎる学びでした読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/08/03/Ansible%E3%81%A7alb%E3%81%AB%E5%8B%95%E7%9A%84%E3%81%ABEC2%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B?utm_source=feed","isoDate":"2018-08-03T02:29:15.000Z","dateMiliSeconds":1533263355000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Ansible初心者ならはじめの一冊におすすめ | Ansible徹底入門 | 書評","contentSnippet":"経緯仕事でAWSの環境構築をAnsibleで書くことになったため、Ansibleとはなにか？どんな機能があるのかなど網羅的に学びたかった為に読みましたAnsible徹底入門: クラウド時代の新しい構成管理の実現作者:廣川 英寿翔泳社AmazonAnsibleとはなにか？本書のChapter 1ではAnsibleの歴史、説明だけでなく、クラウドの登場によってインフラ運用の面から Infrastracture as Codeという概念が出てくる時代背景の中でのAnsibleの立ち位置が書かれており、時代の流れの一緒に学べましたその他Ansibleの使い方に関してはステップバイステップで学ぶことができるので、途中でわからなくなるということはないかと思いますAnsible徹底入門: クラウド時代の新しい構成管理の実現作者:廣川 英寿翔泳社Amazon読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/08/02/Ansible%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AA%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%81%AE%E4%B8%80%E5%86%8A%E3%81%AB%E3%81%8A%E3%81%99%E3%81%99%E3%82%81_%7C_Ansible%E5%BE%B9%E5%BA%95%E5%85%A5%E9%96%80_%7C_?utm_source=feed","isoDate":"2018-08-02T02:41:26.000Z","dateMiliSeconds":1533177686000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Rubyで文字列内の\\nが改行コードとして認識されないとき","contentSnippet":"最初に書いたコード次に試してみたコード正しく改行されるコード様々な改行コードを統一して\\n に変換して、DB保存したいと思ったが、改行コードではなく文字列として保存されてしまいハマりました最初に書いたコードstr = 'Hello! \\nWorld'str.gsub(/(\\\\r\\\\n|\\\\r|\\\\n)/, '\\n')User.name = strUser.save!=> \"Hello! \\\\nWorld\"これだと\\n が文字列として保存されてしまいました。\\n は特殊文字だからエスケープとかすればいいのかな？と思い次にこんなコードを書きました次に試してみたコードstr = 'Hello! \\nWorld'str.gsub(/(\\\\r\\\\n|\\\\r|\\\\n)/, '\\\\\\\\n')=> \"Hello! \\\\nWorld\"こちらもうまく動かずよく調べてみると正しく改行されるコードダブルクォーテーションにすればよいだけでしたバックスラッシュ記法は文字列をダブルクオーテーションで囲った場合とシングルクオーテーションで囲った場合で扱いが異なります。バックスラッシュ記法によるエスケープstr = 'Hello! \\nWorld'str.gsub(/(\\\\r\\\\n|\\\\r|\\\\n)/, \"\\n\")User.name = strUser.save!=> \"Hello! \\n\" + \"World\"     読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/08/01/Ruby%E3%81%A7%E6%96%87%E5%AD%97%E5%88%97%E5%86%85%E3%81%AE%5Cn%E3%81%8C%E6%94%B9%E8%A1%8C%E3%82%B3%E3%83%BC%E3%83%89%E3%81%A8%E3%81%97%E3%81%A6%E8%AA%8D%E8%AD%98%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84?utm_source=feed","isoDate":"2018-08-01T02:28:29.000Z","dateMiliSeconds":1533090509000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"大規模サービス運営にはどんな技術力が必要か学べる | Web開発者のための大規模サービス技術入門 | 書評","contentSnippet":"経緯大量にトラフィックがある大規模サービスはどうやって運用していくのか、どうやって高パフォーマンスを保つのかについて学びたいと思い読みました[Web開発者のための]大規模サービス技術入門 ―データ構造、メモリ、OS、DB、サーバ/インフラ (WEB+DB PRESS plusシリーズ)作者:伊藤 直也,田中 慎司技術評論社Amazon大規模サービスで気をつけるのはI/O負荷をどうするか？大規模サービスを運営していく上でI/O負荷をどうするか？が肝となってくるので、DBをどうやって扱うのかが本書の第2回〜第4回までに渡って書かれていますI/Oの負荷を軽減するにはOSのキャッシュをうまく使うことキャッシュに乗り切らない大容量データの場合にどうするのか？どうやって分散するのか？どうやってスケールさせるか？インデッックスの運用はどうするか？が特に勉強になりました。大規模サービスを運用していく上ではDBの工夫OSの工夫がそれぞれ必要で総合的に対応する必要があるということが学べましたその他その他にも、データサイズが大きいデータをどう扱うか。スケーラビリティの確保に必要な考え方、冗長性の確保なども記載されており、幅広く知識をつけられます[Web開発者のための]大規模サービス技術入門 ―データ構造、メモリ、OS、DB、サーバ/インフラ (WEB+DB PRESS plusシリーズ)作者:伊藤 直也,田中 慎司技術評論社Amazon読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/07/31/%E5%A4%A7%E8%A6%8F%E6%A8%A1%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E9%81%8B%E5%96%B6%E3%81%AB%E3%81%AF%E3%81%A9%E3%82%93%E3%81%AA%E6%8A%80%E8%A1%93%E5%8A%9B%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%8B%E5%AD%A6?utm_source=feed","isoDate":"2018-07-30T23:07:32.000Z","dateMiliSeconds":1532992052000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"ソースコード読む手順と便利な機能をまとめてみました","contentSnippet":"Railsのソースコードリーディングを続ける上で自分流のOSSのソースコードを読む手順とこんな機能、ツールがあると読みやすいよというのをまとめてみましたqiita.comコードリーディングを続けていくうちに、さらにいい方法があれば追記していきたいと思いますblog.shitake4.tech読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/07/30/%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%80%E6%89%8B%E9%A0%86%E3%81%A8%E4%BE%BF%E5%88%A9%E3%81%AA%E6%A9%9F%E8%83%BD%E3%82%92%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%BF?utm_source=feed","isoDate":"2018-07-30T02:57:36.000Z","dateMiliSeconds":1532919456000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsで許可するハッシュキーを設定する | rails commit log流し読みを読んでみた","contentSnippet":"1. 概要@y_yagiさんのrails commit log流し読みを読んでいての学びを書いてみます2. 読んだエントリy-yagi.hatenablog.com3. わからなかったことPRの中の処理に書かれていた.assert_valid_keys ってどんな処理か対象のPRgithub.com記述内容def _define_before_model_callback(klass, callback)  klass.define_singleton_method(\"before_#{callback}\") do |*args, **options, &block|    options.assert_valid_keys :if, :unless, :prepend    set_callback(:\"#{callback}\", :before, *args, **options, &block)  endend4. 調べてみたassert_valid_keys が分からなかった為、どんなメソッドなのか調べてみましたValidates all keys in a hash match *valid_keys, raising ArgumentError on a mismatch.Note that keys are treated differently than HashWithIndifferentAccess, meaning that string and symbol keys will not match.{ name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises \"ArgumentError: Unknown key: :years. Valid keys are: :name, :age\"{ name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises \"ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'\"{ name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing引用：Ruby on Rails 5.2.0assert_valid_keys の引数に入れた値がレシーバのkeyに存在するかチェックするメソッドですassert_valid_keys の引数に設定した値のうち１つしか含んでいない場合となります5. さきほどのソースコードを読んでみるさきほどの記述の assert_valid_keys の部分を見てみるとoptions.assert_valid_keys :if, :unless, :prependoptionsに設定した値にif, unless, prepend 以外のキーが存在しないかチェックしており、それ以外がある場合は、ArgumentErrorをraiseします読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/07/25/Rails%E3%81%A7%E8%A8%B1%E5%8F%AF%E3%81%99%E3%82%8B%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%AD%E3%83%BC%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B_%7C_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD?utm_source=feed","isoDate":"2018-07-25T00:54:04.000Z","dateMiliSeconds":1532480044000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Hash#fetchでブロックを記述した場合の挙動 | rails commit log流し読みを読んでみた","contentSnippet":"1. 概要@y_yagiさんのrails commit log流し読みを読んでいての学びを書いてみます2. 読んだエントリy-yagi.hatenablog.com3. わからなかったことPRの中の処理に書かれていたHash#fetchにブロックを渡すとどうなるかdef log_to_stdout?  options.fetch(:log_to_stdout) do    options[:daemon].blank? && environment == \"development\"  endend4. PRを読んでみる対象のPRgithub.com1. どんな修正内容？ railties/lib/rails/commands/server/server_command.rbの修正です。rails commit log流し読み(2018/07/09)5. PR読んでてわからない部分調べてみた1. Hash#fetch にブロックを渡すとどんな挙動になる？ fetch(key, default = nil) {|key| ... } -> object[permalink][rdoc]Ruby 2.5.0 リファレンスマニュアル Hash#fetchハッシュにkeyが存在しない場合は、ブロックの評価値が戻り値となるようです実際の挙動を確認してみましたブロックの評価値trueが戻り値となりましたここまでを踏まえ、さきほどのPRの内容を見てみると、def log_to_stdout?  options.fetch(:log_to_stdout) do    options[:daemon].blank? && environment == \"development\"  endendoptionsに log_to_stdout が設定されていない場合、options[:daemon]がblankかつ環境がdevelopmentだとログ出力をするという処理になります読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/07/10/%23_Hash%23fetch%E3%81%A7%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%92%E8%A8%98%E8%BF%B0%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AE%E6%8C%99%E5%8B%95_%7C_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD?utm_source=feed","isoDate":"2018-07-10T02:46:01.000Z","dateMiliSeconds":1531190761000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support mattr_reader編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所mattr_reader を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます3.2.3 モジュール属性mattr_reader、mattr_writer、mattr_accessorという3つのマクロは、クラス用に定義されるcattr_*マクロと同じです。実際、cattr_*マクロは単なるmattr_*マクロの別名です。クラス属性も参照してください。たとえば、これらのマクロは以下のDependenciesモジュールで使用されています。module ActiveSupport  module Dependencies    mattr_accessor :warnings_on_first_load    mattr_accessor :history    mattr_accessor :loaded    mattr_accessor :mechanism    mattr_accessor :load_paths    mattr_accessor :load_once_paths    mattr_accessor :autoloaded_constants    mattr_accessor :explicitly_unloadable_constants    mattr_accessor :logger    mattr_accessor :log_activity    mattr_accessor :constant_watch_stack    mattr_accessor :constant_watch_stack_mutex  endend  引用：RAILS GUIDE#モジュール属性ソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def mattr_reader を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > module > attribute_accessors.rbdef mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil)   syms.each do |sym|     raise NameError.new(\"invalid attribute name: #{sym}\") unless /\\A[_A-Za-z]\\w*\\z/.match?(sym)     class_eval(<<-EOS, __FILE__, __LINE__ + 1)       @@#{sym} = nil unless defined? @@#{sym}       def self.#{sym}         @@#{sym}       end     EOS     if instance_reader && instance_accessor       class_eval(<<-EOS, __FILE__, __LINE__ + 1)         def #{sym}           @@#{sym}         end       EOS     end     sym_default_value = (block_given? && default.nil?) ? yield : default     class_variable_set(\"@@#{sym}\", sym_default_value) unless sym_default_value.nil?   end end alias :cattr_reader :mattr_readerまずここまでの処理を見てみますsyms.each do |sym|  raise NameError.new(\"invalid attribute name: #{sym}\") unless /\\A[_A-Za-z]\\w*\\z/.match?(sym)symsはsymbolsを短縮した名前で、変数に入る内容は、シンボルの配列ではないかと推測できますunless 以下の正規表現 /\\A[_A-Za-z]\\w*\\z/ を見てみると\\A は文字列の先頭にマッチ[_A-Za-z] は指定された文字のどれかに一致\\w は英単語を構成する文字(a~z,A~Z,_,1~9)* は0回以上の繰り返しにマッチ\\z は文字列の末尾にマッチ上記の条件に当てはまるシンボルにマッチするかを検査しています_hoge, Huga1 などがマッチしますこれにマッチしない場合は NameError 例外を発生させるということになります※ 正規表現について詳しくは以下を参照qiita.comdocs.ruby-lang.orgマッチした場合は、以下の処理が実行されますclass_eval(<<-EOS, __FILE__, __LINE__ + 1)  @@#{sym} = nil unless defined? @@#{sym}  def self.#{sym}    @@#{sym}  endEOSclass_evalにより引数のヒアドキュメントの内容をクラス内でそのまま実行することになります　　モジュールのコンテキストで文字列 expr またはモジュール自身をブロックパラメータとするブロックを 評価してその結果を返します。モジュールのコンテキストで評価するとは、実行中そのモジュールが self になるということです。 つまり、そのモジュールの定義式の中にあるかのように実行されます。ただし、ローカル変数は module_eval/class_eval の外側のスコープと共有します。文字列が与えられた場合には、定数とクラス変数のスコープは自身のモジュール定義式内と同じスコープになります。 ブロックが与えられた場合には、定数とクラス変数のスコープはブロックの外側のスコープになります。class Cenda = 1C.class_eval %Q{  def m                   # メソッドを動的に定義できる。    return :m, #{a}  end}p C.new.m        #=> [:m, 1]引用：Ruby2.5.0リファレンスマニュアル#class_evalヒアドキュメントの処理をそれぞれ見ていきます  @@#{sym} = nil unless defined? @@#{sym} では変数symのクラス変数が自クラスに定義されているかを確認していますそして、こちらではクラス変数のアクセッサ(クラスメソッド)を定義していますdef self.#{sym}  @@#{sym}end次にこちらを見ていきますif instance_reader && instance_accessor  class_eval(<<-EOS, __FILE__, __LINE__ + 1)    def #{sym}      @@#{sym}    end  EOSendinstance_reader && instance_accessor こちらはメソッドの引数の値によって、判定されます。（デフォルトはどちらもtrueの為、実行されます）  def mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil)こちらの記述は先程のクラス変数のアクセッサとほぼ同一ですが、こちらはクラスメソッドではなく、インスタンスメソッドになりますclass_eval(<<-EOS, __FILE__, __LINE__ + 1)  def #{sym}    @@#{sym}  endEOS※クラスメソッド、インスタンスメソッドの定義の方法については以下参照 qiita.com次にこちらを見ていきますsym_default_value = (block_given? && default.nil?) ? yield : defaultclass_variable_set(\"@@#{sym}\", sym_default_value) unless sym_default_value.nil?ブロックが与えられているかつメソッドの引数defaultがnilの場合に、ブロックの返り値をsym_default_value変数に代入していますsym_default_valueがnilでないときに、クラス変数に値を代入していますmattr_readerにはエイリアスも設定されており、cattr_readerも同じ処理を行うことができますalias :cattr_reader :mattr_reader読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/07/09/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_mattr_reader%E7%B7%A8?utm_source=feed","isoDate":"2018-07-09T03:51:10.000Z","dateMiliSeconds":1531108270000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"to_symを使わずに文字列からシンボルを生成 | rails commit log流し読みを読んでみた","contentSnippet":"概要日課のrails commit log流し読みを読んでいて、文字列からシンボルに変換する方法が to_sym 以外にあることがわかったので、備忘録も兼ねて書いてみました対象のコミットgithub.comto_sym を使わずに、シンボルを作る今までは \"hoge\".to_sym で文字列からシンボル作っていたのですが、to_symメソッドまたはinternメソッドは、文字列に対応するシンボル（Symbolオブジェクト）を返します。s = \"hello\"p s.to_syms = \"symbol with spaces\"p s.to_sym引用：Rubyリファレンス#to_sym,intern:\"hoge\" でもシンボルを作れるようです読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/05/29/to_sym%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%9A%E3%81%AB%E6%96%87%E5%AD%97%E5%88%97%E3%81%8B%E3%82%89%E3%82%B7%E3%83%B3%E3%83%9C%E3%83%AB%E3%82%92%E7%94%9F%E6%88%90_%7C_rails_commit_log%E6%B5%81%E3%81%97?utm_source=feed","isoDate":"2018-05-29T02:19:19.000Z","dateMiliSeconds":1527560359000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support attr_internal編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所attr_internal を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますあるクラスで属性を定義すると、後にそのクラスのサブクラスが作成されるときに名前が衝突するリスクが生じます。これはライブラリにおいては特に重要な問題です。Active Supportでは、attr_internal_reader、attr_internal_writer、attr_internal_accessorというマクロが定義されています。これらのマクロは、Rubyにビルトインされているattr_*と同様に振る舞いますが、内部のインスタンス変数の名前が衝突しにくいように配慮される点が異なります。attr_internalマクロはattr_internal_accessorと同義です。# ライブラリclass ThirdPartyLibrary::Crawler  attr_internal :log_levelend# クライアントコードclass MyCrawler < ThirdPartyLibrary::Crawler  attr_accessor :log_levelend引用：RAILS GUIDES#内部属性サブクラスに定義した名前が衝突してしまうケースを発生させない為の機能になりますソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def attr_internal を探してみます2. attr_internal関連の処理がまとまってそうなファイルが見つかったので、みてみます1. activesupport > lib > active_support > core_ext > module > attr_internal.rb省略alias_method :attr_internal, :attr_internal_accessor省略20行目でalias_methodを使用し、attr_internal_accessor に attr_internal という別名を付け、こちらでも呼び出せるようにしていますalias_methodメソッドは、クラスやモジュールのメソッドに別名を付けます。引数には新しい別名new_name、元のメソッド名original_nameを順に指定します。戻り値はクラスやモジュール自身です。別名を付けると、通常のメソッド呼び出しのように別名でメソッドを呼び出せるようになります。class Cat  def message() \"meow\" end  alias_method :welcome, :messageendcat = Cat.newputs cat.welcome引用：Rubyリファレンス#alias_methodattr_internal_accessor の処理を見てみます省略# Declares an attribute reader and writer backed by an internally-named instance# variable.def attr_internal_accessor(*attrs)  attr_internal_reader(*attrs)  attr_internal_writer(*attrs)end省略内部でそれぞれ処理を呼んでいるだけのメソッドになります# frozen_string_literal: trueclass Module  # Declares an attribute reader backed by an internally-named instance variable.  def attr_internal_reader(*attrs)    attrs.each { |attr_name| attr_internal_define(attr_name, :reader) }  end  # Declares an attribute writer backed by an internally-named instance variable.  def attr_internal_writer(*attrs)    attrs.each { |attr_name| attr_internal_define(attr_name, :writer) }  end省略それぞれの処理を見てみると、受け取った引数（属性名の配列）を eachで１つずつ取り出し attr_internal_define に渡している処理になりますattr_internal_define という名前から推測すると内部属性の読み取り、書き取りを定義している処理で引数の :reader、:writer で読み取り用、書き込み用の処理を動的に定義しているのではと思われます。attr_internal_define を見てみます省略private省略  def attr_internal_define(attr_name, type)    internal_name = attr_internal_ivar_name(attr_name).sub(/\\A@/, \"\")    # use native attr_* methods as they are faster on some Ruby implementations    send(\"attr_#{type}\", internal_name)    attr_name, internal_name = \"#{attr_name}=\", \"#{internal_name}=\" if type == :writer    alias_method attr_name, internal_name    remove_method internal_name  endendattr_internal_ivar_name(attr_name) の戻り値から @ を取り除いて、internal_name 変数に入れています。send(\"attr_#{type}\", internal_name) ではtypeがreaderである場合はインスタンス変数の読み込み用メソッド、 writerである場合は、書き込み用メソッドを定義しています次の行ではtypeがwriterである場合は、新しく定義するアクセッサ−をattr_name 変数へ、内部で使用するアクセッサーを internal_name へ入れていますalias_method で新しく定義するアクセッサーへと変更していますあるクラスで属性を定義すると、後にそのクラスのサブクラスが作成されるときに名前が衝突するリスクが生じます。これはライブラリにおいては特に重要な問題です。に、 remove_method で send(\"attr_#{type}\",internal_name) で定義したアクセッサーを削除しています読んでみてライブラリを作る時にアクセッサーを定義した場合には、なるべく使うようにしないとバグを生み出す可能性がかなり高くなりそうだと感じました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/05/10/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_attr_internal%E7%B7%A8?utm_source=feed","isoDate":"2018-05-10T02:42:33.000Z","dateMiliSeconds":1525920153000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support alias_attribute編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所alias_attribute を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます3.2 属性3.2.1 alias_attributeモデルの属性には、リーダー (reader)、ライター (writer)、述語 (predicate) があります。上に対応する3つのメソッドを持つ、モデルの属性の別名 (alias) を一度に作成することができます。他の別名作成メソッドと同様、1つ目の引数には新しい名前、2つ目の引数には元の名前を指定します (変数に代入するときと同じ順序、と覚えておく手もあります)。class User < ActiveRecord::Base  # emailカラムを\"login\"という名前でも参照したい  # そうすることで認証のコードがわかりやすくなる  alias_attribute :login, :emailend引用：RAILS GUIDESソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def alias_attribute を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > moudle > aliasing.rb# frozen_string_literal: trueclass Module  # Allows you to make aliases for attributes, which includes  # getter, setter, and a predicate.  #  #   class Content < ActiveRecord::Base  #     # has a title attribute  #   end  #  #   class Email < Content  #     alias_attribute :subject, :title  #   end  #  #   e = Email.find(1)  #   e.title    # => \"Superstars\"  #   e.subject  # => \"Superstars\"  #   e.subject? # => true  #   e.subject = \"Megastars\"  #   e.title    # => \"Megastars\"  def alias_attribute(new_name, old_name)    # The following reader methods use an explicit `self` receiver in order to    # support aliases that start with an uppercase letter. Otherwise, they would    # be resolved as constants instead.    module_eval <<-STR, __FILE__, __LINE__ + 1      def #{new_name}; self.#{old_name}; end          # def subject; self.title; end      def #{new_name}?; self.#{old_name}?; end        # def subject?; self.title?; end      def #{new_name}=(v); self.#{old_name} = v; end  # def subject=(v); self.title = v; end    STR  endendmodule_eval メソッドに対して ヒアドキュメントで文字列（def〜STRの上の行まで）、__FILE__、 __LINE__ + 1を渡しています※ヒアドキュメントとは？Rubyのヒアドキュメント 4パターンのまとめ -- ぺけみさお第２引数、第３引数に記述されている __FILE__, __LINE__ +1  がわからなかったので、調べてみました__FILE__現在のソースファイル名フルパスとは限らないため、フルパスが必要な場合は File.expand_path(__FILE__) とする必要があります。__LINE__ 現在のソースファイル中の行番号  フルパスとは限らないため、フルパスが必要な場合は File.expand_path(__FILE__) とする必要があります。引用：#疑似変数疑似変数と呼ばれる特殊な変数のようです。実は nil,true,false も疑似変数でそれぞれのクラス(NilClass, TrueClass, FalseClass)の唯一のインスタンスが格納されているようですmodule_evalを調べてみるとモジュールのコンテキストで文字列 expr またはモジュール自身をブロックパラメータとするブロックを 評価してその結果を返します。モジュールのコンテキストで評価するとは、実行中そのモジュールが self になるということです。 つまり、そのモジュールの定義式の中にあるかのように実行されます。ただし、ローカル変数は module_eval/class_eval の外側のスコープと共有します。文字列が与えられた場合には、定数とクラス変数のスコープは自身のモジュール定義式内と同じスコープになります。 ブロックが与えられた場合には、定数とクラス変数のスコープはブロックの外側のスコープになります。[PARAM] expr:評価される文字列。[PARAM] fname:文字列を指定します。ファイル fname に文字列 expr が書かれているかのように実行されます。 スタックトレースの表示などを差し替えることができます。[PARAM] lineno:文字列を指定します。行番号 lineno から文字列 expr が書かれているかのように実行されます。 スタックトレースの表示などを差し替えることができます。例:class Cenda = 1C.class_eval %Q{  def m                   # メソッドを動的に定義できる。    return :m, #{a}  end}p C.new.m        #=> [:m, 1]引用：Ruby 2.5.0 リファレンスマニュアル#class_evalつまり、moduleに動的にでセッターメソッド、ゲッターメソッドと真偽値を返すメソッドを定義しているということになりますqiita.com読んでみて__FILE__ や __LINE__ はコード読んでいるとちょくちょく出てきてたので、そこは気にせず、読んでましたが、ちゃんと調べてみると新たな発見があったので、ソースコードをしっかりと読み込むことは大切だと感じました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/04/24/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_alias_attribute%E7%B7%A8?utm_source=feed","isoDate":"2018-04-24T02:46:07.000Z","dateMiliSeconds":1524537967000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Vim入門でつまづいたが再入門しました","contentSnippet":"1. 経緯今更ながらですが、Vimに入門してみました2. 何をしたのか？Vim関連の情報収集初心者向けにわかりやすくまとめてある記事が多く、最初からこれを読んでおけばよかったと後悔Gitのコミットログ書くときはvimでなど、色々な場面でvimをなるべく使うようにしました最初はなれなくてかなりストレスでしたが、少しづつ手に馴染んでくるまでなんとか耐えて乗り切りました3. 使ってみてどうだったか？1週間ほど使ってますが、以前より書きやすくなってきています。コマンドの数が多いので、チートシートみながらだったりしますが、覚えれば、覚えるほど、作業が楽になっていく実感あります編集モードとノーマルモードの行き来がめんどうだな〜と思っていましたが、この記事（初心者こそ、お洒落でvimらしい使い方を学ぼう！）を読んで考えが変わりましたコマンドは数が多すぎて最初に一気に覚えるのは大変だったので、こちらの記事（知識0から始めるVim講座）を参考にステップ毎に覚えていきました4. 調べた記事1. vimって何？というところから【初心者必見】最強エディタVimの使い方/コマンド30種まとめVim初心者に捧ぐ実践的入門知識0から始めるVim講座初心者こそ、お洒落でvimらしい使い方を学ぼう！『実践Vim』を読んで学んだ、おすすめVimデフォルト機能35個2.オススメプラグイン脱初心者を目指すVimmerにオススメしたいVimプラグインや.vimrcの設定vimをもっと便利にするおすすめプラグイン5. まとめ更にVimを使いこなせるようになれば、サーバー入っての作業とか色々と楽になりそうだな〜という感じです","link":"https://blog.shitake4.tech/entry/2018/04/12/Vim%E5%85%A5%E9%96%80%E3%81%A7%E3%81%A4%E3%81%BE%E3%81%A5%E3%81%84%E3%81%9F%E3%81%8C%E5%86%8D%E5%85%A5%E9%96%80%E3%81%97%E3%81%BE%E3%81%97%E3%81%9F?utm_source=feed","isoDate":"2018-04-12T02:23:58.000Z","dateMiliSeconds":1523499838000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support in?編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所in? を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます述語in?は、あるオブジェクトが他のオブジェクトに含まれているかどうかをテストします。渡された引数がinclude?に応答しない場合はArgumentError例外が発生します。in?の例を示します。1.in?([1,2])        # => true\"lo\".in?(\"hello\")   # => true25.in?(30..50)      # => false1.in?(1)            # => ArgumentError  引用：RAILS GUIDES：in?ソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def in? を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > object > inclusion.rbclass Object  # Returns true if this object is included in the argument. Argument must be  # any object which responds to +#include?+. Usage:  #  #   characters = [\"Konata\", \"Kagami\", \"Tsukasa\"]  #   \"Konata\".in?(characters) # => true  #  # This will throw an +ArgumentError+ if the argument doesn't respond  # to +#include?+.  def in?(another_object)    another_object.include?(self)  rescue NoMethodError    raise ArgumentError.new(\"The parameter passed to #in? must respond to #include?\")  end省略end引数(another_object)に対してinclude?を実行していますinclude?を調べてみますarray.include?(obj)include?メソッドは、配列の要素に引数objが含まれていればtrue、なければfalseを返します。要素と引数objが同じかどうかの比較には==メソッドが使われます。animals = [\"dog\", \"cat\", \"mouse\"]puts animals.include?(\"cat\")puts animals.include?(\"elephant\")truefalse引用：Rubyリファレンス#include?(Array)str.include?(other_str)include?メソッドは、文字列の中に引数other_strの文字列が含まれるかどうかを調べます。含まれるときはtrue、含まれないときはfalseを返します。s = \"Supercalifragilisticexpialidocious\"puts s.include?(\"exp\")true引用：Rubyリファレンス#include?(String)mod.include?(other_mod)include?メソッドは、クラスやモジュールが引数のモジュールother_modをインクルードしているかどうかを調べます。インクルードしていればtrueを、そうでなければfalseを返します。親クラスがインクルードしているモジュールを指定してもtrueになります。p String.include?(Comparable)p String.include?(Enumerable)p String.include?(Kernel)truetrue  (Ruby 1.9ではfalse)true引用：Rubyリファレンス#include?(Module)rubyのinclude?の実装は3つあるみたいです(String, Array, Module)another_object.include?(self) は引数のオブジェクトがレシーバに対してinclude?かどうかをチェックしていますそして、メソッドが実装されていない場合には、 ArgumentError を返すという処理になっていましたrescue NoMethodError  raise ArgumentError.new(\"The parameter passed to #in? must respond to #include?\")end読んでみてinclude? はよく使用していますが、in?はあまり馴染みがなかったので、挙動を学べたので、うまく使い分けなど出来るといいなと思います読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/04/06/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_in%3F%E7%B7%A8?utm_source=feed","isoDate":"2018-04-06T02:37:02.000Z","dateMiliSeconds":1522982222000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"peco使ってみたらすごい便利だった","contentSnippet":"先日、リモートでRails Developers Meetupのセッション聞いてまして、railsdm.github.ioリモート着席— しいたけ (@shitake4) 2018年3月24日   ちょっと気になるツールがあったので、調査してみて数日間使ってみました紹介されていたのは、@itoさんのセッションでpecoというツールが紹介されていましたので、色々と調べて実際に使ってみましたpecoとは？pecoの基礎の基礎Github:pecoとてもシンプルなツールで 「標準入力から受けた行データをインクリメンタルサーチして、選択した行を標準出力に返す」 コマンドです。pecoの基礎の基礎pecoを利用した設定pecoるpecoを使い始めた私のpeco活用事例pecoでエンジニア人生を10倍楽にしよう！pecoの便利な関数を集約した奴がいたんですよぉ〜調べてみると、peco単体で使うよりもよく検索に使う処理と組み合わせて、というパターンが多かったです。1. find file (^w)  rspecでテストケースを指定したい場合、前まではzshの補完を使っていたのですが、ディレクトリが深かったりすると指定するのがめんどくさかったりと大変だったのですが、これを設定したことでいっきに楽になりました私のpeco活用事例#4. peco find file2. search branch (alias -g B)  ブランチ切り替えする際に、なんとなく名前を覚えているんだけど、どんな名前だっけ？という時にいちいちローカルに落としているブランチ一覧から探していくのが結構めんどくさかったので、非常に助かりました。ちょくちょくマージされたブランチとかは消しているけど、気づくとすごい数増えていたりするのでこれで作業が楽になったのは間違いないです私のpeco活用事例#2. peco git branch3. select-history (^r)  引数が微妙に違うコマンドとかをヒストリ検索するのは結構めんどいな〜という感じだったので、これが使えるようになって一気に入力が容易になりましたpecoを使い始めた#peco-select-history4. cdr (^@)  こちらも非常にお世話になってます。よく移動するディレクトリで階層深かったりすると移動が面倒でした。この作業の効率化は結構バカにならないな〜と思いますpecoを使い始めた#peco-cdrpecoファイルの運用方法前と大体同じ感じでやる。基本的にこういうツールは自分でいろいろ作りたくなってきて、設定が増えてきて破滅するので、ファイルを置くディレクトリを決めておいてそこに置いておくことにする。キーバインドの設定zsh/peco-sources/ : peco用の設定ファイルを置いておく用pecoを使い始めた#pecoのファイル運用shiba_yu36氏と全く同じ運用にしています。複数Macで使いたいので、ファイルはDropboxに置いて、シンボリックリンクを張るという感じで運用しています数日間使ってみての感想とにかく便利の一言に尽きます！上記で設定してない場合で使いたいときは  | peco  で使えるので、どんなパターンでも柔軟に活躍してくれます。何かよく使うパターンがあれば、その時にまたファイルを追加したいな〜と思います読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/04/02/peco%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F%E3%82%89%E3%81%99%E3%81%94%E3%81%84%E4%BE%BF%E5%88%A9%E3%81%A0%E3%81%A3%E3%81%9F?utm_source=feed","isoDate":"2018-04-02T05:47:00.000Z","dateMiliSeconds":1522648020000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"わからないこと調べてみた | rails commit log流し読みを読んでみた","contentSnippet":"1. 概要@y_yagiさんのrails commit log流し読みを読んでいてわからなかったこと調べてみました2. 読んだエントリy-yagi.hatenablog.com3. わからなかったことPRの中の処理に書かれていたrack_app < Rails::Engine とは何だろう？4. PRを読んでみる対象のPRgithub.com1. どんな修正内容？Make engine check more explicitrails commit log流し読み(2018/03/25)2. 対象のPRの内容5. PR読んでてわからない部分調べてみた1. rack_app < Rails::Engine とは何だろう？記述箇所は該当PRの下記部分になりますdef engine?  rack_app.is_a?(Class) && rack_app < Rails::Engineend特定のクラスを継承しているかチェックしている処理とのことでした※ 調べてみたら@semind氏のQiitaに記事がありましたqiita.com実際の挙動を確認してみました継承関係にあったので、戻り値がtrueになっていますdef engine? の処理はrack_app.is_a?(Class) && rack_app < Rails::Enginerack_app がクラスであり、かつ Rails::Engine を継承しているかを判定している処理でした読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/03/27/%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F_%7C_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD%E3%81%BF%282018/03/25%29?utm_source=feed","isoDate":"2018-03-27T02:34:43.000Z","dateMiliSeconds":1522118083000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support silence_warnings編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所silence_warnings を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますブロックが継続する間$VERBOSEの値を変更し、その後リセットします。silence_warnings { Object.const_set \"RAILS_DEFAULT_LOGGER\", logger }suppressメソッドを使用すると例外の発生を止めることもできます。このメソッドは、例外クラスを表す任意の数値を受け取ります。suppressは、あるブロックの実行時に例外が発生し、その例外が(kind_of?による判定で)いずれかの引数に一致する場合、それをキャプチャして例外を発生せずに戻ります。一致しない場合、例外はキャプチャされません。# ユーザーがロックされていればインクリメントは失われるが、重要ではないsuppress(ActiveRecord::StaleObjectError) do  current_user.increment! :visitsend引用：RAILS GUIDES#2.13 警告・例外の抑制ソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def silence_warnings を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > kernel > reporting.rb# frozen_string_literal: truemodule Kernel  module_function  # Sets $VERBOSE to +nil+ for the duration of the block and back to its original  # value afterwards.  #  #   silence_warnings do  #     value = noisy_call # no warning voiced  #   end  #  #   noisy_call # warning voiced  def silence_warnings    with_warnings(nil) { yield }  end省略endwith_warnings メソッドにブロックを渡してます。  そのブロック内で yield しているので、元は silence_warnings に渡したブロックですsilence_warnings { puts 'ブロック実行' }このように書いた場合は、 {}の内容がwith_warnings へそのままブロックとして渡すという感じになります※ ブロックの詳しい説明は@kidach1氏のこちらの記事を参考にしてくださいqiita.comsilence_warnings の処理を見てみます省略# Sets $VERBOSE for the duration of the block and back to its original# value afterwards.def with_warnings(flag)  old_verbose, $VERBOSE = $VERBOSE, flag  yieldensure  $VERBOSE = old_verboseend省略仮引数flag には nil が入ります次に変数の初期化処理　  old_verbose, $VERBOSE = $VERBOSE, flag で、$VERBOSE がどんなものなのかわからなかったので、調べてみます冗長メッセージフラグです。Rubyインタプリタへの コマンドラインオプション -v でセットされます。nil警告を出力しないfalse重要な警告のみ出力 (デフォルト)trueすべての警告を出力する$VERBOSE に nil, false 以外を代入すると値は true になります。Ruby2.5.0リファレンスマニュアル#variable $-vwith_warningsメソッド内ではブロック実行前に $VERBOSE へ nilを入れることで警告を出力しないモードへと変更yield でブロックを実行ブロック実行後、もともと設定されていた$VERBOSE へ設定し直すという処理になります読んでみて普段は使っていない機能だったので、どんな挙動するのか手探りで読んでました。使い所がまだ理解できていないので、このような機能があることを覚えておき、使えるようにしておくのが、良さそうだと思いました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/03/26/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_silence_warnings%E7%B7%A8?utm_source=feed","isoDate":"2018-03-26T05:24:10.000Z","dateMiliSeconds":1522041850000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"わからないこと調べてみた | rails commit log流し読み(2018/03/15)","contentSnippet":"1. 概要@y_yagiさんのrails commit log流し読みを読んでいてわからなかったこと調べてみました2. 読んだエントリy-yagi.hatenablog.com3. わからなかったことPRの中の処理に書かれていたZlib::Deflate.deflate とは何だろう？PRの中の処理に書かれていたMarshal.dump とは何だろう？4. PRを読んでみる対象のPRgithub.com1. どんな修正内容？activesupport/lib/active_support/cache.rb の修正です。ActiveSupport::Cache::Entry で保存するオブジェクトを複数回marshalしていたのを、値をキャッシュして複数回marshalしないよう修正しています。  rails commit log流し読み(2018/03/15)2. 複数回実施しているところは？initialize 内の処理でshould_compress?がtrueだった場合、should_compress?と compress で2回 Marshal.dump(@value) が実行されている為、should_compress? 実行時にインスタンス変数に格納し、 compress 実行時にはそのインスタンス変数内のデータを再度利用することで、複数回実施しないようにしているようです変更箇所def should_compress?def compressdef marshaled_value5. PR読んでてわからない部分調べてみた1. Zlib::Deflate.deflate とは何だろう？string を圧縮します。level の有効な値は Zlib::NO_COMPRESSION, Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION 及び 0 から 9 の整数です。ちなみに、このメソッドは以下のコードとほぼ同じです:require 'zlib'def deflate(string, level)  z = Zlib::Deflate.new(level)  dst = z.deflate(string, Zlib::FINISH)  z.close  dstend引用：Ruby 2.5.0 リファレンスマニュアル class Zlib::Deflate文字列を圧縮する際に使うメソッドのようです実際の挙動を確認してみましたちなみに、zlib自体はRubyの機能ではなくgzipのメイン開発者が、\"Deflate\"アルゴリズム処理部分だけを緩いライセンスで実装したライブラリ。Linux/UNIXだけでなく、Windowsなど幅広いプラットフォームに移植されている。技術/歴史/zip,gzip,zlib,bzip2ということのようですその後、gzipの主要開発者であるJean-Loup Gailly と Mark Adler らは\"Deflate\"圧縮アルゴリズム処理だけをライブラリとして実装し、\"zlib\"として商用利用も可能な緩いライセンスで公開する。 技術/歴史/zip,gzip,zlib,bzip22. Marshal.dump とは何だろう？obj を指定された出力先に再帰的に出力します。ファイルに書き出せないオブジェクトをファイルに書き出そうとすると 例外 TypeError が発生します。 ファイルに書き出せないオブジェクトは以下の通りです。名前のついてない Class/Module オブジェクト。(この場 合は、例外 ArgumentError が発生します。無名クラスについて は、Module.new を参照。)システムがオブジェクトの状態を保持するもの。具体的には以下のイン スタンス。Dir, File::Stat, IO とそのサブクラス File, Socket など。MatchData, Data, Method, UnboundMethod, Proc, Thread, ThreadGroup, Continuation のインスタンス。特異メソッドを定義したオブジェクトまた、これらのオブジェクトを間接的に指すオブジェクトなども書き出せ ません。例えば、デフォルト値を求めるブロックを持った Hash は Proc を間接的に指していることになります。p Marshal.dump(Hash.new {})=> -:1:in `dump': cannot dump hash with default proc (TypeError)引用：Ruby 2.5.0 リファレンスマニュアル module Marshal実際の挙動を確認してみました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/03/16/%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F_%7C_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD%E3%81%BF%282018/03/15%29?utm_source=feed","isoDate":"2018-03-16T05:13:34.000Z","dateMiliSeconds":1521177214000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support instance_variable_names編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所instance_variable_names を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますinstance_variable_namesメソッドは配列を返します。配列のインスタンス名には\"@\"記号が含まれます。class C  def initialize(x, y)    @x, @y = x, y  endendC.new(0, 1).instance_variable_names # => [\"@x\", \"@y\"]  引用：RAILS GUIDES：instance_variable_namesソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def instance_variable_names を探してみます2. 該当箇所が1箇所あったので、みてみます1. activesupport > lib > active_support > core_ext > object > instance_variables.rb# frozen_string_literal: trueclass Object省略  # Returns an array of instance variable names as strings including \"@\".  #  #   class C  #     def initialize(x, y)  #       @x, @y = x, y  #     end  #   end  #  #   C.new(0, 1).instance_variable_names # => [\"@y\", \"@x\"]  def instance_variable_names    instance_variables.map(&:to_s)  endendまず、 instance_variables.map() を見てますinstance_variables を調べてみるとinstance_variablesメソッドは、レシーバのオブジェクトが持っているインスタンス変数の名前を配列に入れて返します。Ruby 1.9 Ruby 1.8では配列中の変数名は文字列ですが、Ruby 1.9ではシンボルになります。class Book  def initialize(title, price)    @title = title; @price = price  endendbook = Book.new(\"Programming Ruby\", 2000)p book.instance_variables[\"@title\", \"@price\"]   (Ruby 1.8の場合）[:@title, :@price]     (Ruby 1.9の場合）引用：Rubyリファレンス：instance_variablesインスタンス変数の名前を配列で取得しています。そしてその配列に対して map を実行していますmapはmapメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を作成して返します。collectメソッドの別名です。numbers = [\"68\", \"65\", \"6C\", \"6C\", \"6F\"]p numbers.map {|item| item.to_i(16) }[104, 101, 108, 108, 111]引用：Rubyリファレンス：mapブロックの戻り値を集めて配列にするメソッドです次に .map(&:to_s) を見てみます&: は配列の各要素に対して to_s を実行しているということです[1, 2, 3].map(&:to_s)=> [\"1\", \"2\", \"3\"]ということです※詳しい解説は@kasei-san氏のこちらの記事がわかりやすいかと思いますqiita.comつまり、def instance_variable_names はレシーバのインスタンス変数名を配列として取り出すメソッドになります読んでみて今回は、前回書いた instance_values を読んでいたので、すんなりと読めましたshitake4.hatenablog.com","link":"https://blog.shitake4.tech/entry/2018/03/06/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_instance_variable_names%E7%B7%A8?utm_source=feed","isoDate":"2018-03-06T02:45:51.000Z","dateMiliSeconds":1520304351000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Rubyでメソッドチェーンを書く為に覚えておきたいメソッド | rails commit log流し読みを読んでみた","contentSnippet":"1. 概要@y_yagiさんのrails commit log流し読みを読んでいてわからなかったこと調べてみました2. 読んだエントリy-yagi.hatenablog.com3. わからなかったことPRの中の処理に書かれていた.tap ってなんだろう？対象のPRgithub.com記述内容if value.blank? && options[:prompt]  tag_options = { value: \"\" }.tap do |prompt_opts|    prompt_opts[:disabled] = true if options[:disabled] == \"\"    prompt_opts[:selected] = true if options[:selected] == \"\"  end  option_tags = tag_builder.content_tag_string(\"option\", prompt_text(options[:prompt]), tag_options) + \"\\n\" + option_tags end4. 調べてみたtap が分からなかった為、どんなメソッドなのか調べてみましたobj.tap {|myself| block }tapメソッドは、ブロック変数にレシーバ自身を入れてブロックを実行します。戻り値はレシーバ自身です。メソッドチェーンの中にtapメソッドをはさみ込み、ソースコードを簡潔にする目的で使われます。次の例は、文字列中の文字のコードを10進数と16進数で表示するものです。arr = \"hello\".bytes.to_ap arrarr = arr.collect {|byte| byte.to_s(16) }p arrこの例は、tapメソッドを使えば次のように書けます。\"hello\".bytes.to_a.tap {|arr| p arr }  .collect {|byte| byte.to_s(16) }.tap {|arr| p arr }  [104, 101, 108, 108, 111][\"68\", \"65\", \"6c\", \"6c\", \"6f\"]引用：Rubyリファレンス：tap5. さきほどのソースコードを読んでみるさきほどの記述の tap の部分を見てみるとtag_options = { value: \"\" }.tap do |prompt_opts|    prompt_opts[:disabled] = true if options[:disabled] == \"\"    prompt_opts[:selected] = true if options[:selected] == \"\"  endブロック引数の prompt_opts は tap のレシーバである { value: \"\"} となりますoptions[:disabled] == \"\" が真の場合は、 { value: \"\"} に disabled: true が追加されますoptions[:selected] == \"\" が真の場合は、 { value: \"\"} に selected: true が追加されます読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/03/01/%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F_%7C_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD%E3%81%BF%282018/02/28%29?utm_source=feed","isoDate":"2018-03-01T02:39:43.000Z","dateMiliSeconds":1519871983000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support instance_values編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所instance_values を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますinstance_valuesメソッドはハッシュを返します。インスタンス変数名から\"@\"を除いたものがハッシュのキーに、インスタンス変数の値がハッシュの値にマップされます。キーは文字列です。class C  def initialize(x, y)    @x, @y = x, y  endendC.new(0, 1).instance_values # => {\"x\" => 0, \"y\" => 1}引用：RAILS GUIDES：instance_valuesインスタンス変数を簡単に取り出して使うメソッドですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def instance_values を探してみます2. 該当箇所が1個あったので、それをみてみます1. activesupport > lib > active_support > core_ext > object > instance_values.rb# frozen_string_literal: trueclass Object  # Returns a hash with string keys that maps instance variable names without \"@\" to their  # corresponding values.  #  #   class C  #     def initialize(x, y)  #       @x, @y = x, y  #     end  #   end  #  #   C.new(0, 1).instance_values # => {\"x\" => 0, \"y\" => 1}  def instance_values    Hash[instance_variables.map { |name| [name[1..-1], instance_variable_get(name)] }]  endまず、 Hash[] を調べてみますHashクラスのクラスメソッドは、新しいハッシュ（Hashクラスのインスタンス）を返します。の中に[キー1, 値1, キー2, 値2, ...]のようにオブジェクトを並べると、それが新しいハッシュのキーと値になります。[]内のオブジェクトの数が奇数のときは、例外ArgumentErrorが発生します。movie = Hash[:title, \"Alien\", :director, \"Ridley Scott\", :year, 1979]puts movie[:title]puts movie[:year]Alien1979引用：Rubyリファレンス：[]ハッシュクラスのインスタンスを生成するクラスメソッドになります次に、どんな値を元にハッシュ生成しているのか見るため instance_variables.map { |name| [name[1..-1], instance_variable_get(name)] }  を順を追って見てみたいと思いますまず、instance_variables.map {} ですinstance_variables を調べてみるとinstance_variablesメソッドは、レシーバのオブジェクトが持っているインスタンス変数の名前を配列に入れて返します。Ruby 1.9 Ruby 1.8では配列中の変数名は文字列ですが、Ruby 1.9ではシンボルになります。class Book  def initialize(title, price)    @title = title; @price = price  endendbook = Book.new(\"Programming Ruby\", 2000)p book.instance_variables[\"@title\", \"@price\"]   (Ruby 1.8の場合）[:@title, :@price]     (Ruby 1.9の場合）引用：Rubyリファレンス：instance_variablesインスタンス変数の名前を配列で取得しています。そしてその配列に対して map を実行していますmapはmapメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を作成して返します。collectメソッドの別名です。numbers = [\"68\", \"65\", \"6C\", \"6C\", \"6F\"]p numbers.map {|item| item.to_i(16) }[104, 101, 108, 108, 111]引用：Rubyリファレンス：mapブロックの戻り値を集めて配列にするメソッドです次にmapに渡しているブロック部分 { |name| [name[1..-1], instance_variable_get(name)] } を見てみますname[1..-1] はインスタンス変数名から部分文字列を取得している処理ですレシーバがStringクラスだった場合は、次のとおりです文字列の中から部分文字列を取り出すメソッドです。s[2]、s[3,5]、s[2..7]、s[/[0-9]/] のように、いろいろな形で利用できます。配列要素の取り出しのように記述しますが、実際にはメソッド呼び出しです。[]の中はメソッドの引数です。省略引数に範囲を指定すると、その範囲に対応する部分文字列を返します。範囲外の位置を指定すると、nilが返ります。s = \"hello, world\"puts s[7..10]   # 7文字目から10文字目までputs s[7...10]  # 7文字目から10文字目まで、10文字目は含まないworlwor開始位置と終了位置がマイナスの場合は、文字列の末尾から数えます（-1が末尾から1番目、-2が末尾から2番目、...）。s = \"hello, world\"puts s[-5..-1]  # 末尾から5文字目..末尾から1文字目までworld引用：Rubyリファレンス：[] (String)name[1..-1] は2文字目から末尾1文字目までを取得しています\"@title\"であれば title が取得できますレシーバがシンボルだった場合にも同様ですrangeで指定したインデックスの範囲に含まれる部分文字列を返します。(self.to_s[range] と同じです。)[PARAM] range:取得したい文字列の範囲を示す Range オブジェクトを指定します。:foo[0..1] # => \"fo\"[SEE_ALSO] String#[], String#slice引用：Ruby2.5.0リファレンス：Symbol次に、instance_variable_get(name) を見てみますinstance_variable_getメソッドは、レシーバが持っているインスタンス変数の値を返します。引数nameにはインスタンス変数の名前を:@titleや\"@title\"のようにシンボルか文字列で渡します。定義されていない変数名を渡すとnilが返ります。:titleのようにインスタンス変数と見なされない名前を渡すと例外NameErrorが発生します。class Book  def initialize(title)    @title = title  endendbook = Book.new(\"Programming Ruby\")p book.instance_variable_get(:@title)p book.instance_variable_get(:@price)\"Programming Ruby\"nil引用：Ruby2.5.0リファレンス：Symbolインスタンス変数名を引数に渡すとその値が取れるという動きですブロックの中で行っている処理は、配列の先頭にインスタンス変数名、次にインスタンス変数の値をセットしている処理ですたとえば、 { |name| [name[1..-1], instance_variable_get(name)] }　の name が\"@title\" の場合であれば、[\"title\", \"@titleに入ってた値\"] ということになりますここまでをまとめて考えてみると、Hash[] の引数に入る値は、[  [\"インスタンス変数名1\", \"インスタンス変数の値1\"],  [\"インスタンス変数名2\", \"インスタンス変数の値2\"],  [\"インスタンス変数名3\", \"インスタンス変数の値3\"]]になりますHash[] を調べてみると新しいハッシュを生成します。 引数は必ず偶数個指定しなければなりません。奇数番目がキー、偶数番目が値になります。このメソッドでは生成するハッシュにデフォルト値を指定することはできません。 Hash.newを使うか、Hash#default=で後から指定してください。[PARAM] key_and_value:生成するハッシュのキーと値の組です。必ず偶数個(0を含む)指定しなければいけません。[EXCEPTION] ArgumentError:奇数個の引数を与えたときに発生します。以下は配列からハッシュを生成する方法の例です。省略(2) キーと値のペアの配列からハッシュへalist = [[1,\"a\"], [2,\"b\"], [3,[\"c\"]]]p Hash[*alist.flatten(1)]  # => {1=>\"a\", 2=>\"b\", 3=>[\"c\"]}引用：Ruby2.5.0リファレンス：Hash.[]さきほどの配列をHash[] すると{  \"インスタンス変数名1\" => \"インスタンス変数の値1\",  \"インスタンス変数名2\" => \"インスタンス変数の値2\",  \"インスタンス変数名3\" => \"インスタンス変数の値3\"}となります読んでみてインスタンス変数も利用がしやすいようにこんなメソッドもあるんだというのが学びでした読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/02/26/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_instance_values%E7%B7%A8?utm_source=feed","isoDate":"2018-02-26T05:14:44.000Z","dateMiliSeconds":1519622084000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"メソッドが定義されているか確認したい場合のdefined? | rails commit log流し読みを読んでみた","contentSnippet":"1. 概要@y_yagiさんのrails commit log流し読みを読んでいてわからなかったこと調べてみました2. 読んだエントリy-yagi.hatenablog.com3. わからなかったことPRの中の処理に書かれていたdefined? ってなんだろう？対象のPRgithub.com記述内容def config_target_version  defined?(@config_target_version) ? @config_target_version : Rails::VERSION::STRING.to_fend4. 調べてみたdefined?が分からなかった為、どんなメソッドなのか調べてみましたdefined? 式式が定義されていなければ、偽を返します。定義されていれば式の種別 を表す文字列を返します。定義されていないメソッド、undef されたメソッド、Module#remove_method により削除されたメソッドのいずれに対しても defined? は偽を返します。特別な用法として以下があります。defined? yieldyield の呼び出しが可能なら真(文字列 \"yield\")を返します。 Kernel.#block_given? と同様にメソッドがブロック付きで呼ばれたか を判断する方法になります。defined? supersuper の実行が可能なら真(文字列 \"super\")を返します。defined? a = 1p a # => nil引用：Rubyリファレンス2.5.0：defined?式が定義されているかを確認するメソッドのようです以下は、defined? が返す値の一覧です。\"super\"\"method\"\"yield\"\"self\"\"nil\"\"true\"\"false\"\"assignment\"\"local-variable\"\"local-variable(in-block)\"\"global-variable\"\"instance-variable\"\"constant\"\"class variable\"\"expression\"引用：Rubyリファレンス2.5.0：defined?5. ちょっと思ったことこんな書き方def config_target_version  @config_target_version || Rails::VERSION::STRING.to_fendもありなのかなと思ったのですが、 defined? は式が定義されている場合のみ戻り値があるので、少し挙動が変わってしまうので、同じ動きはしないので、これはダメそうでした読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/02/14/%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F_%7C_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD%E3%81%BF%282018/02/13%29?utm_source=feed","isoDate":"2018-02-14T02:43:55.000Z","dateMiliSeconds":1518576235000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support as_json編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所2.11 JSON supportActive Supportが提供するto_jsonメソッドの実装は、通常json gemがRubyオブジェクトに対して提供しているto_jsonよりも優れています。その理由は、HashやOrderedHash、Process::Statusなどのクラスでは、正しいJSON表現を提供するために特別な処理が必要になるためです。RAILS GUIDES：Active Support コア拡張機能：JSON※ to_json についてはこちらの記事を参照くださいshitake4.hatenablog.comここからは上記記事の続きになりますソースコードを読んでみるas_jsonはどんな処理をしているのか見てみます1. activesupport > lib > active_support > core_ext > object > json.rb1. class Objectclass Object  def as_json(options = nil) #:nodoc:    if respond_to?(:to_hash)      to_hash.as_json(options)    else      instance_values.as_json(options)    end  endendレシーバがrespond_to?(:to_hash) できる場合であれば、レシーバをハッシュにし、as_jsonしていますinstance_valuesを呼んでいますinstance_variablesメソッドは、レシーバのオブジェクトが持っているインスタンス変数の名前を配列に入れて返します。Rubyリファレンス」instance_valuesレシーバのインスタンス変数を持った配列に対して as_json していますオブジェクトに対する as_json はハッシュか配列に変換して実行するということになります2. class Hashclass Hash  def as_json(options = nil) #:nodoc:    # create a subset of the hash by applying :only or :except    subset = if options      if attrs = options[:only]        slice(*Array(attrs))      elsif attrs = options[:except]        except(*Array(attrs))      else        self      end    else      self    end    Hash[subset.map { |k, v| [k.to_s, options ? v.as_json(options.dup) : v.as_json] }]  endendsubset = if options省略else  selfendでoptionsが偽の場合はレシーバがsubsetに代入されますif options内をみてみますif attrs = options[:only]  slice(*Array(attrs))elsif attrs = options[:except]  except(*Array(attrs))else  selfendif attrs = options[:only]でattrsに代入し、attrsが真であれ場合 slice(*Array(attrs)) が実行されますHash.slice はactive support の拡張機能になりますSlice a hash to include only the given keys. Returns a hash containing the given keys.{ a: 1, b: 2, c: 3, d: 4 }.slice(:a, :b)# => {:a=>1, :b=>2}This is useful for limiting an options hash to valid keys before passing to a method:  def search(criteria = {})  criteria.assert_valid_keys(:mass, :velocity, :time)endsearch(options.slice(:mass, :velocity, :time))If you have an array of keys you want to limit to, you should splat them:valid_keys = [:mass, :velocity, :time]search(options.slice(*valid_keys))引用：apidock：Ruby on Rails：sliceレシーバから引数に指定した値と一致するキーを含んだハッシュを戻り値とします*Array(attrs) で可変長引数として配列で初期化し、引数に渡していますこの部分の処理はオプション only で指定したキーのみをレシーバから取り出す処理になります次に elsif attrs = options[:except] を見てみますさきほどと似ている記述ですReturns a hash that includes everything but the given keys.hash = { a: true, b: false, c: nil}hash.except(:c) # => { a: true, b: false}hash # => { a: true, b: false, c: nil}This is useful for limiting a set of parameters to everything but a few known toggles:@person.update(params[:person].except(:admin))引用：apidock：Ruby on Rails：except上記2パターンに当てはまらない場合は、レシーバが返ります次に、こちらをみてみます    Hash[subset.map { |k, v| [k.to_s, options ? v.as_json(options.dup) : v.as_json] }]処理を順番に見てみますHash[] はハッシュインスタンスの作成処理ですHashクラスのクラスメソッドは、新しいハッシュ（Hashクラスのインスタンス）を返します。の中に[キー1, 値1, キー2, 値2, ...]のようにオブジェクトを並べると、それが新しいハッシュのキーと値になります。Rubyリファレンス：Hashsubset.map { |k, v|  } はsubset(さきほどのif文内で戻り値ハッシュ) に対して map でkey, valueを取り出しています続いて [k.to_s, options ? v.as_json(options.dup) : v.as_json] を見てみます配列の先頭にkeyをto_sしたものをいれていますoptions ? v.as_json(options.dup) : v.as_json の戻り値が入りますつまり、ここでの処理はハッシュsubsetのキー、バリューそれぞれに対して as_json し、再度ハッシュ生成しています3. class Arrayclass Array  def as_json(options = nil) #:nodoc:    map { |v| options ? v.as_json(options.dup) : v.as_json }  endendレシーバである配列の各要素に対してas_json しています4. class Structclass Struct #:nodoc:  def as_json(options = nil)    Hash[members.zip(values)].as_json(options)  endendここまでHash[members.zip(values)]見てみますHash[] はハッシュの初期化処理ですmembersメソッドを調べてみると、構造体のメンバの名前(文字列)の配列を返します。  Foo = Struct.new(:foo, :bar)p Foo.new.members  # => [\"foo\", \"bar\"][注意] 本メソッドの記述は Struct の下位クラスのインスタンスに対して呼び 出す事を想定しています。Struct.new は Struct の下位クラスを作成する点に 注意してください。  引用：Ruby2.5.0：Structzipメソッドを調べてみるとzipメソッドは、配列の要素を引数の配列other_arrayの要素と組み合わせ、配列の配列を作成して返します。transposeメソッドで[array, other_array, ...].transposeとしたときと同じく、行と列を入れ替えます。ただし、transposeメソッドと違って足りない要素はnilで埋められ、余分な要素は捨てられます。arr1 = [1, 2, 3]arr2 = [4, 5]arr3 = [6, 7, 8, 9]p arr1.zip(arr2, arr3) [[1, 4, 6], [2, 5, 7], [3, nil, 8]]引用：Rubyリファレンス：zipvaluesメソッドを調べてみると 構造体のメンバの値を配列にいれて返します。  require 'etc'print Etc.getpwuid.values.join(\":\"), \"\\n\"引用：Ruby2.5.0：Structここまでをまとめると、構造体からメンバー名とメンバーの値を取り出しハッシュへと変換していますas_json しています5. class TrueClassclass TrueClass  def as_json(options = nil) #:nodoc:    self  endend6. class FalseClassclass FalseClass  def as_json(options = nil) #:nodoc:    self  endend7. class NilClassclass NilClass  def as_json(options = nil) #:nodoc:    self  endend8. class Stringclass String  def as_json(options = nil) #:nodoc:    self  endend9. class Symbolclass Symbol  def as_json(options = nil) #:nodoc:    to_s  endend10. class Numericclass Numeric  def as_json(options = nil) #:nodoc:    self  endend11. class Floatclass Float  # Encoding Infinity or NaN to JSON should return \"null\". The default returns  # \"Infinity\" or \"NaN\" which are not valid JSON.  def as_json(options = nil) #:nodoc:    finite? ? self : nil  endendfinite?  を調べてみると数値が ∞, -∞, あるいは NaN でない場合に true を返します。 そうでない場合に false を返します。Ruby2.5.0リファレンスマニュアル：finite?数値として問題がない場合にレシーバを返すようです12. class BigDecimalclass BigDecimal  # A BigDecimal would be naturally represented as a JSON number. Most libraries,  # however, parse non-integer JSON numbers directly as floats. Clients using  # those libraries would get in general a wrong number and no way to recover  # other than manually inspecting the string with the JSON code itself.  #  # That's why a JSON string is returned. The JSON literal is not numeric, but  # if the other end knows by contract that the data is supposed to be a  # BigDecimal, it still has the chance to post-process the string and get the  # real value.  def as_json(options = nil) #:nodoc:    finite? ? to_s : nil  endendこちらは数値として問題ないか確認後文字列へ変換しています13. class Regexpdef as_json(options = nil) #:nodoc:  to_sendレシーバをそのまま文字列へ変換しています14. module Enumerabledef as_json(options = nil) #:nodoc:  to_a.as_json(options)endmodule Enumerable を調べてみると繰り返しを行なうクラスのための Mix-in。このモジュールの メソッドは全て each を用いて定義されているので、インクルード するクラスには each が定義されていなければなりません。Ruby 2.5.0：Enumerablemapやeach_with_indexなどがインスタンスメソッドとして定義されているクラスですto_a.as_json(options) ですので、レシーバを配列に変換し、as_json しています15. class IOclass IO  def as_json(options = nil) #:nodoc:    to_s  endendレシーバをそのまま文字列へ変換しています16. class Rangeclass Range  def as_json(options = nil) #:nodoc:    to_s  endendレシーバをそのまま文字列へ変換しています17. class Timeclass Time  def as_json(options = nil) #:nodoc:    if ActiveSupport::JSON::Encoding.use_standard_json_time_format      xmlschema(ActiveSupport::JSON::Encoding.time_precision)    else      %(#{strftime(\"%Y/%m/%d %H:%M:%S\")} #{formatted_offset(false)})    end  endendまず ActiveSupport::JSON::Encoding.use_standard_json_time_format を見てみますmodule ActiveSupport  省略  module JSON    省略    module Encoding #:nodoc:      class JSONGemEncoder #:nodoc:        省略      end      class << self        # If true, use ISO 8601 format for dates and times. Otherwise, fall back        # to the Active Support legacy format.        attr_accessor :use_standard_json_time_format        省略        # Sets the precision of encoded time values.        # Defaults to 3 (equivalent to millisecond precision)        attr_accessor :time_precision        省略      end      self.use_standard_json_time_format = true      省略      self.time_precision = 3アクセッサに use_standard_json_time_format が定義されており、デフォルトでtrueに設定されていますas_json 内では基本的に xmlschema(ActiveSupport::JSON::Encoding.time_precision) が実行されそうですActiveSupport::JSON::Encoding.time_precision も同じようにアクセッサが用意されておりますtime_precisionを調べてみると@y_yagi氏のrails commit log流し読み(2014/07/10)で仕様変更の経緯が解説されていましたy-yagi.hatenablog.comtime_precisionはミリ秒の桁数のようですActiveSupport::JSON::Encoding.time_precision = 4に設定してみるとミリ秒の桁数が4桁になりましたxmlschema を調べてみるとXML Scheme (date) による書式の文字列を返します。Ruby2.5.0リファレンス：Date#xmlschema文字列を返すメソッドのようです次に if ActiveSupport::JSON::Encoding.use_standard_json_time_format が偽の場合を見てみますelse  %(#{strftime(\"%Y/%m/%d %H:%M:%S\")} #{formatted_offset(false)})endまず%()を調べてみるとダブルクオートで囲う場合と同等。Rubyで%記法（パーセント記法）を使うダブルクオートと同じようですstrftimeは引数のフォーマット文字列に従って、レシーバを変換し戻り値とします時刻を format 文字列に従って文字列に変換した結果を返します。Ruby2.5.0リファレンス：Time#strftime今回の引数の値の記号の意味はこちらになります%Y…西暦を表す数%m…月を表す数字(01-12)%d…日(01-31)%H…24時間制の時(00-23)%M…分(00-59)%S…秒(00-60) (60はうるう秒)次にformatted_offset(false) を見てみますactive_support > core_ext > time > conversions.rbclass Time  省略  # Returns a formatted string of the offset from UTC, or an alternative  # string if the time zone is already UTC.  #  #   Time.local(2000).formatted_offset        # => \"-06:00\"  #   Time.local(2000).formatted_offset(false) # => \"-0600\"  def formatted_offset(colon = true, alternate_utc_string = nil)    utc? && alternate_utc_string || ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)  endutc? && alternate_utc_string はUTCなのか、またはalternate_urc_stringを設定しているかを判定していますutc? && alternate_utc_string の判定が偽の場合を見てみますActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)　は世界標準時間からの差を出力します※UTCについてはこちらの記事がわかりやすいかと思いますwww.724685.com　18. class Dateclass Date  def as_json(options = nil) #:nodoc:    if ActiveSupport::JSON::Encoding.use_standard_json_time_format      strftime(\"%Y-%m-%d\")    else      strftime(\"%Y/%m/%d\")    end  endendif ActiveSupport::JSON::Encoding.use_standard_json_time_format は 17. class Timeを参照してください19. class DateTimeclass DateTime  def as_json(options = nil) #:nodoc:    if ActiveSupport::JSON::Encoding.use_standard_json_time_format      xmlschema(ActiveSupport::JSON::Encoding.time_precision)    else      strftime(\"%Y/%m/%d %H:%M:%S %z\")    end  endendclass Timeと処理が似ていますuse_standard_json_time_format が真の場合は、 time_precision で指定した桁数でミリ秒で文字列へ変換し戻り値とします20. class URI::Genericclass URI::Generic #:nodoc:  def as_json(options = nil)    to_s  endend21. class Pathnameclass Pathname #:nodoc:  def as_json(options = nil)    to_s  endend22. class Process::Statusclass Process::Status #:nodoc:  def as_json(options = nil)    { exitstatus: exitstatus, pid: pid }  endendProcess::Status クラスがどのようなものか調べてみるとプロセスの終了ステータスを表すクラスです。 メソッド Process.#wait2 などの返り値として使われます。Ruby2.5.0：class Process::Statusexitstatus はexited? が真の場合プロセスが返した終了ステータスの整数を、そ うでない場合は nil を返します。Ruby2.5.0：class Process::Statuspid は終了したプロセスのプロセス ID を返します。Ruby2.5.0：class Process::Statusそれぞれの値をハッシュにし戻り値としています23. class Exceptionclass Exception  def as_json(options = nil)    to_s  endend読んでみてJSON化するために様々なクラスをオープンクラスしていたので、Railsを使わずにJSONの処理をするときには気をつけないと思っていない挙動することがありそうだと思いました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/02/13/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_as_json%E7%B7%A8?utm_source=feed","isoDate":"2018-02-13T02:34:41.000Z","dateMiliSeconds":1518489281000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support to_json編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所2.11 JSON supportActive Supportが提供するto_jsonメソッドの実装は、通常json gemがRubyオブジェクトに対して提供しているto_jsonよりも優れています。その理由は、HashやOrderedHash、Process::Statusなどのクラスでは、正しいJSON表現を提供するために特別な処理が必要になるためです。RAILS GUIDES：Active Support コア拡張機能：JSONJSON を見てみますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますReturns a JSON string representing the hash.  Without any options, the returned JSON string will include all the hash keys. For example:    { :name => \"Konata Izumi\", 'age' => 16, 1 => 2 }.to_json  # => {\"name\": \"Konata Izumi\", \"1\": 2, \"age\": 16}  引用：API dock：to_jsonレシーバに対して to_jsonすると、JSON文字列を返すという処理ですthinkit.co.jpソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def to_json を探してみます2. 該当箇所が2個ほどあったので、それぞれみてみます1. activesupport > lib > active_support > core_ext > object > json.rb1. module ActiveSupport::ToJsonWithActiveSupportEncodermodule ActiveSupport  module ToJsonWithActiveSupportEncoder # :nodoc:    def to_json(options = nil)      if options.is_a?(::JSON::State)        # Called from JSON.{generate,dump}, forward it to JSON gem's to_json        super(options)      else        # to_json is being invoked directly, use ActiveSupport's encoder        ActiveSupport::JSON.encode(self, options)      end    end  endendメソッド to_json のみ実装されたモジュールですさらに読み進めてみますObject, Array, FalseClass, Float, Hash, Integer, NilClass, String, TrueClass, Enumerable].reverse_each do |klass|  klass.prepend(ActiveSupport::ToJsonWithActiveSupportEncoder)endreverse_each の挙動を調べてみますanimals = [\"dog\", \"cat\", \"mouse\"]animals.reverse_each {|anim| puts anim }mouse  cat  dog引用：Rubyリファレンス：reverse_eachEnumerableから順番に klass へ各要素が入ります次にブロックの中klass.prepend(ActiveSupport::ToJsonWithActiveSupportEncoder)を見てみますprependがわからないので、調べてみると指定したモジュールを self の継承チェインの先頭に「追加する」ことで self の定数、メソッド、モジュール変数を「上書き」します。Ruby2.5.0：prepend配列のクラス [Object, Array, FalseClass, Float, Hash, Integer, NilClass, String, TrueClass, Enumerable] にモジュールを追加して to_json をオーバーライドしてますdef to_json(options = nil)  if options.is_a?(::JSON::State)    # Called from JSON.{generate,dump}, forward it to JSON gem's to_json    super(options)  else    # to_json is being invoked directly, use ActiveSupport's encoder    ActiveSupport::JSON.encode(self, options)  endendoptionに ::JSON::State を指定した場合には、super(options) により継承元の to_json を呼んでいますActiveSupport::JSON.encode(self, options) となりますencodeの処理を見てみます2. activesupport > lib > active_support > json > encoding.rbmodule JSON  # Dumps objects in JSON (JavaScript Object Notation).  # See http://www.json.org for more info.  #  #   ActiveSupport::JSON.encode({ team: 'rails', players: '36' })  #   # => \"{\\\"team\\\":\\\"rails\\\",\\\"players\\\":\\\"36\\\"}\"  def self.encode(value, options = nil)    Encoding.json_encoder.new(options).encode(value)  end引数valueに入るのは to_json した際のレシーバです次に Encoding.json_encoderまでみてみますmodule ActiveSupport省略  module JSON省略    module Encoding #:nodoc:省略    self.json_encoder = JSONGemEncoder    self.time_precision = 3    endmodule Encoding内でjson_encoderにJSONGemEncoderクラスをセットしていますJSONGemEncoderクラスのinitializerでは引数のオプションをインスタンス変数に入れていますmodule Encoding #:nodoc:  class JSONGemEncoder #:nodoc:    attr_reader :options    def initialize(options = nil)      @options = options || {}    endここまでみると Encoding.json_encoder.new(options) の戻り値は JSONGemEncoderクラスのインスタンスです省略class JSONGemEncoder #:nodoc:省略# Encode the given object into a JSON stringdef encode(value)  stringify jsonify value.as_json(options.dup)end上記は括弧が省略されていますが、 stringify(jsonify(value.as_json(options.dup))) と同義ですvalue.as_jsonでvalueは to_json した際のレシーバですので、ハッシュなどになりますjsonifyをみてみます# Convert an object into a \"JSON-ready\" representation composed of# primitives like Hash, Array, String, Numeric,# and +true+/+false+/+nil+.# Recursively calls #as_json to the object to recursively build a# fully JSON-ready object.## This allows developers to implement #as_json without having to# worry about what base types of objects they are allowed to return# or having to remember to call #as_json recursively.## Note: the +options+ hash passed to +object.to_json+ is only passed# to +object.as_json+, not any of this method's recursive +#as_json+# calls.def jsonify(value)  case value  when String    EscapedString.new(value)  when Numeric, NilClass, TrueClass, FalseClass    value.as_json  when Hash    Hash[value.map { |k, v| [jsonify(k), jsonify(v)] }]  when Array    value.map { |v| jsonify(v) }  else    jsonify value.as_json  endendStringクラスの場合には# This class wraps all the strings we see and does the extra escapingclass EscapedString < String #:nodoc:  def to_json(*)    if Encoding.escape_html_entities_in_json      super.gsub ESCAPE_REGEX_WITH_HTML_ENTITIES, ESCAPED_CHARS    else      super.gsub ESCAPE_REGEX_WITHOUT_HTML_ENTITIES, ESCAPED_CHARS    end  end  def to_s    self  endend上記EscapedStringクラスに値を入れ直して、newしていますNumeric, NilClass, TrueClass, FalseClassの場合には、as_jsonするだけになりますHashクラスの場合もみてみますHash[value.map { |k, v| [jsonify(k), jsonify(v)] }]まずvalue.map { |k, v| [jsonify(k), jsonify(v)] } ではvalue(ハッシュ)のkey,valueをそれぞれjsonifyし、2次元配列を作っています[['hoge', 'huga'],['piyo', 'poyo']]メソッドの内部で再度同じメソッドを呼ぶことが不思議に思えるかもしれませんが、再帰といいます※ 再帰とはどのようなものかはこちらの記事がわかりやすいかと思います再帰呼び出しmapはブロックの戻り値を配列化しますブロックの内部ではハッシュのキー、バリューを jsonifyし配列を作成していますHash[] の処理を調べてみます新しいハッシュを生成します。 引数は必ず偶数個指定しなければなりません。奇数番目がキー、偶数番目が値になります。  このメソッドでは生成するハッシュにデフォルト値を指定することはできません。 Hash.newを使うか、Hash#default=で後から指定してください。  [PARAM] key_and_value:生成するハッシュのキーと値の組です。必ず偶数個(0を含む)指定しなければいけません。[EXCEPTION] ArgumentError:奇数個の引数を与えたときに発生します。以下は配列からハッシュを生成する方法の例です。 省略4) キーや値が配列の場合alist = [[1,[\"a\"]], [2,[\"b\"]], [3,[\"c\"]], [[4,5], [\"a\", \"b\"]]]hash = Hash[alist] # => {1=>[\"a\"], 2=>[\"b\"], 3=>[\"c\"], [4, 5]=>[\"a\", \"b\"]}引用：Ruby2.5.0：Hashhashの各キー、バリューをjsonifyし、再度ハッシュを作り直すという処理になりますArrayクラスの場合を見てみます  value.map { |v| jsonify(v) }配列の各要素に対して jsonify しています上記以外の場合はjsonify value.as_json引数を as_json しているので、上記クラスのどれかになるまで処理が繰り返されますここまでが to_json の処理になりますjson.rb ではさきほど見てきた処理以外にもオープンクラスして as_json  メソッドを定義している箇所があります読んでみてjson化する処理はよく使ったりするので、調べてみて内部で何をしているのか把握することは大切だと感じました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/02/05/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_to_json%E7%B7%A8?utm_source=feed","isoDate":"2018-02-05T02:45:09.000Z","dateMiliSeconds":1517798709000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support with_options編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所with_options を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますwith_optionsメソッドは、連続した複数のメソッド呼び出しに対して共通して与えられるオプションを解釈するための手段を提供します。class Account < ActiveRecord::Base    has_many :customers, dependent: :destroy    has_many :products,  dependent: :destroy  has_many :invoices,  dependent: :destroy  has_many :expenses,  dependent: :destroy end  上は以下のようにできます。class Account < ActiveRecord::Base  with_options dependent: :destroy do |assoc|    assoc.has_many :customers    assoc.has_many :products    assoc.has_many :invoices    assoc.has_many :expenses  endend引用：RAILS GUIDES：Active Support コア拡張機能#with_options読んでみましたが、イマイチ使い方がわからなかったので、さらに調べてみますwith_optionsの引数に渡したHashのオプションの値がブロック内に適用されます。上の例ではhash_manyのdependentオプションを共通化しましたが、他のパターンでも適用できます。例えば、モデルの例では他にもvalidatesメソッドのオプションを共通化など使えます。Railsのwith_options上記例であれば、ハッシュである dependent: :destroy を共通化して各 has_many :xxx の引数に渡すという感じですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def with_options を探してみます2. 該当箇所をみてみます1. activesupport > lib > active_support > core_ext > object > with_options.rb# frozen_string_literal: truerequire \"active_support/option_merger\"class Object省略def with_options(options, &block)  option_merger = ActiveSupport::OptionMerger.new(self, options)  block.arity.zero? ? option_merger.instance_eval(&block) : block.call(option_merger)endまず引数を見てみますoptions は dependent: :destroy となります&block はdo |assoc|  assoc.has_many :customers  assoc.has_many :products  assoc.has_many :invoices  assoc.has_many :expensesendまでとなりますそれではwith_optionsのメソッドのロジックをみていきますoption_merger = ActiveSupport::OptionMerger.new(self, options) で ActiveSupport::OptionMerger が何をしているのかわからないので、こちらのコードを読んでみますactivesupport > lib > active_support > option_merger.rb# frozen_string_literal: truerequire \"active_support/core_ext/hash/deep_merge\"module ActiveSupport  class OptionMerger #:nodoc:    instance_methods.each do |method|      undef_method(method) if method !~ /^(__|instance_eval|class|object_id)/    end    def initialize(context, options)      @context, @options = context, options    end    private      def method_missing(method, *arguments, &block)        if arguments.first.is_a?(Proc)          proc = arguments.pop          arguments << lambda { |*args| @options.deep_merge(proc.call(*args)) }        else          arguments << (arguments.last.respond_to?(:to_hash) ? @options.deep_merge(arguments.pop) : @options.dup)        end        @context.__send__(method, *arguments, &block)      end  endendnewした際の引数self, options がインスタンス変数 context, optionsにそれぞれ格納されます次に block.arity.zero? ? option_merger.instance_eval(&block) : block.call(option_merger) です条件式 ? 真（true）の場合に実行される : 偽（false）の場合に実行される という書き方は三項演算子というものですarity を調べるとメソッドが受け付ける引数の数を返します。Ruby2.5.0リファレンスマニュアル：arityzero? を調べると自身がゼロの時、trueを返します。そうでない場合は false を返します。引用：Ruby2.5.0リファレンスマニュアル：arityつまり、条件式 block.arity.zero? はブロックが受け付ける引数の数がゼロかを判定しています条件式が真の場合に実行される option_merger.instance_eval(&block) を見てみますinstance_evalメソッドは、渡されたブロックをレシーバのインスタンスの元で実行します。ブロックの戻り値がメソッドの戻り値になります。Rubyリファレンス：instance_evalつまりoption_merger.instance_eval(&block) とはインスタンスoption_mergerでブロックの内容が実行されるということですdo  has_many :customers  has_many :products  has_many :invoices  has_many :expensesendで定義されていた  has_many メソッドは option_mergerで定義されていないので、 最終的に method_missing となります※ method_missingについて参考：qiita.com呼び出されるmethod_missingはoption_mergerのプライベートメソッドでオーバーライドしている method_missingとなりますprivate  def method_missing(method, *arguments, &block)    if arguments.first.is_a?(Proc)      proc = arguments.pop      arguments << lambda { |*args| @options.deep_merge(proc.call(*args)) }    else      arguments << (arguments.last.respond_to?(:to_hash) ? @options.deep_merge(arguments.pop) : @options.dup)    end    @context.__send__(method, *arguments, &block)  endmethod_missing の引数に入る値はさきほどのブロックの例だとmethod = hash_many , *arguments = [:customers] ですif から else までみてみますif arguments.first.is_a?(Proc)  proc = arguments.pop  arguments << lambda { |*args| @options.deep_merge(proc.call(*args)) }elsearguments配列の先頭がProcだった場合という意味になりますdef method_missing　end を選択し、選択箇所のコミットを見てみますoption_mergerでlambdaもマージできるようにしたということだけがわかりましたが、どんなコードになるのか想像できなかったので、テストケースをみてみますdef test_nested_method_with_options_using_lambda  local_lambda = lambda { { lambda: true } }  with_options(@options) do |o|    assert_equal @options.merge(local_lambda.call),      o.method_with_options(local_lambda).call  endendハッシュを返すlambdaを定義しています@options と method_with_options は同じクラス内に定義されていたので、見てみるとclass OptionMergerTest < ActiveSupport::TestCase  def setup    @options = { hello: \"world\" }  end省略  private    def method_with_options(options = {})      options    endendブロック内で定義されているメソッドのoptionに当たる部分がlambdaだった場合に、正しく動くかをテストしてます次に proc = arguments.pop を見ますpopメソッドは、配列の末尾の要素を削除し、その要素を返します。レシーバ自身を変更するメソッドです。配列が空のときはnilを返します。Rubyリファレンス：popelse から end までみてみますelse  arguments << (arguments.last.respond_to?(:to_hash) ? @options.deep_merge(arguments.pop) : @options.dup)end三項演算子の条件式部分の (arguments.last.respond_to?(:to_hash) をみますargumentsに入るのはブロックで定義したメソッドの引数部分となりますdef hoge(value, option)endのように引数の最後に記述することが多いので、引数の最後の値がハッシュを返すかを確認していますto_hash はHashやArrayなどで定義されています三項演算子の判定結果が真の場合 @options.deep_merge(arguments.pop) を見てみます@options は with_optionsメソッドで第一引数に入れたハッシュでしたdeep_mergeについて調べてみると先の例で説明したとおり、キーがレシーバと引数で重複している場合、引数の側の値が優先されます。RAILS GUIDES：Active Support コア拡張機能#deep_mergearguments.pop は、さきほどの例def hoge(value, option) でいうと arguments = [value, option] となっているのを .pop することで option を取り出し arguments = [value] へと破壊的変更をすることです判定結果が偽の場合 @options.dup も見ますcloneメソッドとdupメソッドは、レシーバのオブジェクトのコピーを作成して返します。オブジェクトのコピーとは、同じ内容を持つ別のオブジェクトです。具体的には、元のオブジェクトと同じクラスの新しいオブジェクトで、元のオブジェクトのインスタンス変数を新しいオブジェクトにコピーしたものです。Rubyリファレンス：clone, dupwith_optionsメソッドで第一引数に入れたハッシュをコピーして返却するだけですarguments << はそれぞれの判定結果の戻り値ハッシュをargumentsに追加しています最後に @context.__send__(method, *arguments, &block) をみます@context はwith_optionsのレシーバです__send__ を調べてみますsendメソッドは、sendの別名です。レシーバの持っているメソッドを呼び出します。Rubyリファレンス：sendwith_optionsのレシーバに対してブロックで定義したメソッドを実行しています読んでみてmethod_missingを利用したプログラミングを初めて見ることができたので、非常に勉強になりました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/01/30/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_with_options%E7%B7%A8?utm_source=feed","isoDate":"2018-01-30T02:37:31.000Z","dateMiliSeconds":1517279851000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"はてなブログで引用文内にコードを挿入する方法","contentSnippet":"マークダウン記法で記述している際に、引用した文章内にコードブロックを挿入したかったのですが、うまくできずハマったので、解決方法を書いてみますやりたいことClass Hoge  def huga    puts 'huga!'  endend解決方法HTMLタグ <blockquote> 内にコードブロックを書く書き方読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/01/26/%E3%81%AF%E3%81%A6%E3%81%AA%E3%83%96%E3%83%AD%E3%82%B0%E3%81%A7%E5%BC%95%E7%94%A8%E6%96%87%E5%86%85%E3%81%AB%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%8C%BF%E5%85%A5%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95?utm_source=feed","isoDate":"2018-01-26T07:44:25.000Z","dateMiliSeconds":1516952665000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support to_query編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事で読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照くださいshitake4.hatenablog.com読んだ箇所to_query を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますこのメソッドは、エスケープされていないkeyを受け取ると、そのキーをto_paramが返す値に対応させるクエリ文字列の一部を生成します  Active Support コア拡張機能：present使い方はこんな感じのようですcurrent_user.to_query('user') # => \"user=357-john-smith\"引数=レシーバを変換した値 という文字列を生成しますソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def to_query を探してみます2. 該当箇所が3個ほどあったので、それぞれみてみますactivesupport > lib > active_support > core_ext > object > to_query.rb1. class Objectclass Object省略  # Converts an object into a string suitable for use as a URL query string,  # using the given <tt>key</tt> as the param name.  def to_query(key)    \"#{CGI.escape(key.to_param)}=#{CGI.escape(to_param.to_s)}\"  endendまず CGI.escape() を見てみます与えられた文字列を URL エンコードした文字列を新しく作成し返します。引用：Rubyリファレンスマニュアル：CGI.escape文字列の引数を１つ取り、それに対してURLエンコードする処理です CGI.escape() の引数部分 key.to_param で何をやっているのかは以前書いたこちらを参照くださいshitake4.hatenablog.com続いて、 CGI.escape(to_param.to_s)を見ますCGI.escape はさきほどと同様ですto_param.to_s はレシーバを to_param し、その戻り値を to_sしていますto_s はレシーバを文字列に変換するメソッドですArrayFixnumStringObjectここまでをまとめるとkey=valueという文字列を生成するメソッドになりますkey部分を生成する際には to_query の引数に対して to_paramし、それをHTMLエスケープして作りますto_paramし、それをHTMLエスケープするということです2. class Arrayclass Array省略  # Converts an array into a string suitable for use as a URL query string,  # using the given +key+ as the param name.  #  #   ['Rails', 'coding'].to_query('hobbies') # => \"hobbies%5B%5D=Rails&hobbies%5B%5D=coding\"  def to_query(key)    prefix = \"#{key}[]\"    if empty?      nil.to_query(prefix)    else      collect { |value| value.to_query(prefix) }.join \"&\"    end  endend変数prefixの値の例を見てみますprefix = \"rubyMine[]\"という文字列になります次にif empty? を見てみますempty?メソッドは、配列が空であればtrue、1つ以上の要素があればfalseを返します。 Rubyリファレンス：empty?if empty? はレシーバである配列の中身が空であるかを判定しています次の処理nil.to_query(prefix)を見てみます最後に collect { |value| value.to_query(prefix) }.join \"&\" を見ますcollect { |value| value.to_query(prefix) } ではレシーバに対して collect を実行していますcollectメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を作成して返します。ブロック引数itemには各要素が入ります。Rubyリファレンス：collectnumbers = [\"68\", \"65\", \"6C\", \"6C\", \"6F\"]p numbers.collect {|item| item.to_i(16) }=> [104, 101, 108, 108, 111]引用： Rubyリファレンス：collectレシーバの中身1つずつに対して、value.to_query(prefix) を実行しています.join \"&\" では配列中身を&で連結し文字列生成していますjoinの挙動はこちらですjoinメソッドは、配列の各要素を文字列に変換し、引数sepを区切り文字として結合した文字列を返します。Rubyリファレンス：join読んでみてHTTPGetメソッドでパラメータを生成する際の使用するメソッドはWebサービスを作る上で欠かせないものだったりするので、他のフレームワークや言語で作る際にはここで読んだ内容が活かせるなと思いました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/01/25/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_to_query%E7%B7%A8?utm_source=feed","isoDate":"2018-01-25T02:49:17.000Z","dateMiliSeconds":1516848557000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support to_param編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照くださいshitake4.hatenablog.com読んだ箇所to_param を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますRailsのあらゆるオブジェクトはto_paramメソッドに応答します。Active Support コア拡張機能：to_paramソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def to_param を探してみます2. 該当箇所が8個ほどあったので、それぞれみてみます1. activesupport > lib > active_support > core_ext > object > to_query.rb1. class Object# frozen_string_literal: truerequire \"cgi\"class Object  # Alias of <tt>to_s</tt>.  def to_param    to_s  end単純にto_s しているだけです2. class NilClassclass NilClass  # Returns +self+.  def to_param    self  endendレシーバ自身を返していますNilClassの戻り値はnilですので、このようなコードでもいいのではないか？と思いましたdef to_param  nilendもしかしたらコミットログに戻り値をselfにした理由や経緯があるかもしれないと思ったので、調べてみます残念ながら1コミットしかなかったため、わかりませんでした3. class TrueClassclass TrueClass  # Returns +self+.  def to_param    self  endend4. class FalseClassclass FalseClass  # Returns +self+.  def to_param    self  endend5. class Arrayclass Array  # Calls <tt>to_param</tt> on all its elements and joins the result with  # slashes. This is used by <tt>url_for</tt> in Action Pack.  def to_param    collect(&:to_param).join \"/\"  endレシーバに対して collect を実行していますcollectメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を作成して返します。ブロック引数itemには各要素が入ります。Rubyリファレンス：collectnumbers = [\"68\", \"65\", \"6C\", \"6C\", \"6F\"]p numbers.collect {|item| item.to_i(16) }=> [104, 101, 108, 108, 111]引用： Rubyリファレンス：collectmapも同じ処理を行うメソッドです(&:to_param) の&:は配列の各要素に対して to_param を実行しています[1, 2, 3].map(&:to_s)=> [\"1\", \"2\", \"3\"]という感じです ※詳しい解説は@kasei-san氏のこちらの記事がわかりやすいかと思いますqiita.com各要素に to_param した配列に対して .join しています joinメソッドは、配列の各要素を文字列に変換し、引数sepを区切り文字として結合した文字列を返します。Rubyリファレンス：join配列の中身を連結し文字列に変換する処理です  array = [\"Ruby\", \"Mine\"]puts array.join(\", \")の場合は Ruby, Mine と出力されます区切り文字がなが場合はarray = [\"Ruby\", \"Mine\"]puts array.joinRubyMine　というようにそのまま連結し出力しますということで .join \"/\"　ではto_param された各要素を\"/\"で連結し、文字列として出力するという処理になります2. activesupport > lib > active_support > core_ext > string > output_safety.rbmodule ActiveSupport #:nodoc:  class SafeBuffer < String中略    def to_param      to_str    endStringを拡張したSafeBufferクラスのインスタンスに対して to_param するのは to_str と同様になります  選択範囲をSafeBufferクラス内にしコミットログを調べますclass SafeBuffer < String省略end一番古いコミットログを見付け足ので、こちらのリビジョンナンバーをコピーしRailsのリポジトリで調べますGitHubの検索窓にさきほどコピーしたリビジョンナンバーをペーストし検索します該当のコミットを見てみるとパフォーマンスの改善の為 html_safe を呼び出す場合にはSafeBufferを使うということでしたStringに追加していると + や << を実行する時に遅くなっているということでした読んでみてコミットログを追ってみるとなぜ実装されているのかが分かるので、コードを読み込むだけでなく、歴史まで追ってみるとより理解が深まるなと思いました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/01/18/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_to_param%E7%B7%A8?utm_source=feed","isoDate":"2018-01-18T03:58:35.000Z","dateMiliSeconds":1516247915000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | Active Support acts_like?編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照くださいshitake4.hatenablog.com読んだ箇所acts_like? を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます2.7 acts_like?(duck)ActiveSupport コア機能：acts_like?レシーバのクラスが引数に入れたクラスと同じ振る舞いをするか確認するメソッドですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能ですので、activesupportディレクトリのlib配下で def acts_like? を探してみます2. 該当箇所が1箇所あったので、それぞれみてみますactivesupport > lib > active_support > core_ext > object > acts_like.rb# frozen_string_literal: trueclass Object  # A duck-type assistant method. For example, Active Support extends Date  # to define an <tt>acts_like_date?</tt> method, and extends Time to define  # <tt>acts_like_time?</tt>. As a result, we can do <tt>x.acts_like?(:time)</tt> and  # <tt>x.acts_like?(:date)</tt> to do duck-type-safe comparisons, since classes that  # we want to act like Time simply need to define an <tt>acts_like_time?</tt> method.  def acts_like?(duck)    case duck    when :time      respond_to? :acts_like_time?    when :date      respond_to? :acts_like_date?    when :string      respond_to? :acts_like_string?    else      respond_to? :\"acts_like_#{duck}?\"    end  endendレシーバに acts_like_引数 メソッドが実装されているか確認していますacts_like_引数 メソッドの内、time, date, stringはactivesupport内ですでに実装されているということがここらか分かりました それでは acts_like_引数 はどう実装すればいいのか見てみます3. まずはdef acts_like_time? を探してみます4. 該当箇所が4箇所あったので、それぞれ見てみますそのままtrueで返しています1. activesupport > lib > active_support > core_ext > date_time > acts_like.rb# frozen_string_literal: truerequire \"date\"require \"active_support/core_ext/object/acts_like\"class DateTime  # Duck-types as a Date-like class. See Object#acts_like?.  def acts_like_date?    true  end  # Duck-types as a Time-like class. See Object#acts_like?.  def acts_like_time?    true  endend2. activesupport > lib > active_support > time_with_zone.rb# So that +self+ <tt>acts_like?(:time)</tt>.def acts_like_time?  trueend3. activesupport > lib > active_support > core_ext > time > acts_like.rb# frozen_string_literal: truerequire \"active_support/core_ext/object/acts_like\"class Time  # Duck-types as a Time-like class. See Object#acts_like?.  def acts_like_time?    true  endend4. activesupport > test > core_ext > object > acts_like_test.rbテスト用に定義されたものの為、省略します4. 次にdef acts_like_date? を探してみます5. 該当箇所が2箇所あったので、それぞれ見てみますさきほどと重複になりますが、そのままtrueを返しています1. activesupport > lib > active_support > core_ext > date_time > acts_like.rb# frozen_string_literal: truerequire \"date\"require \"active_support/core_ext/object/acts_like\"class DateTime  # Duck-types as a Date-like class. See Object#acts_like?.  def acts_like_date?    true  end  # Duck-types as a Time-like class. See Object#acts_like?.  def acts_like_time?    true  endend2. activesupport > lib > active_support > core_ext > date > acts_like.rb# frozen_string_literal: truerequire \"active_support/core_ext/object/acts_like\"class Date  # Duck-types as a Date-like class. See Object#acts_like?.  def acts_like_date?    true  endend5. 最後にdef acts_like_string? を探してみます5. 該当箇所が2箇所あったので、それぞれ見てみますさきほどと重複になりますが、そのままtrueを返しています1. activesupport > lib > active_support > core_ext > string > behavior.rb# frozen_string_literal: trueclass String  # Enables more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.  def acts_like_string?    true  endend2. guides > source > active_support_core_extensions.mdソースコードではなくactivesupportのcore_extensionのドキュメントだったのでここでは省略します6. 一応さきほど調べた以外の def acts_like_xxx が存在しないか確認してみます他の実装はありませんでした読んでみて安全なダックタイピングをするために acts_like_xxx が実装されているのは知りませんでした読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/01/15/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_Active_Support_acts_like%3F%E7%B7%A8?utm_source=feed","isoDate":"2018-01-15T02:41:49.000Z","dateMiliSeconds":1515984109000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport class_eval編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所仕事でもたまに使われてたりする class_eval を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますclass_eval on an object acts like singleton_class.class_eval.Ruby on Rails API：class_eval調べてみてもどんな動きをするのか分かりませんでしたsingleton_class.class_eval のように振る舞うそうなので、調べてみますまずはsingleton_classですsingleton_classメソッドは、オブジェクトの特異クラスを返します。Rubyリファレンス：singleton_class次にclass_evalですclass_evalメソッドは、ブロックをクラス定義やモジュール定義の中のコードであるように実行します。ブロックの戻り値がメソッドの戻り値になります。Rubyリファレンス：class_eval使い方はこんなかんじですclass User    attr_accessor :name    def initialize(name)      @name = name    end    [:downcase, :upcase].each do |method|      class_eval <<-EOS        def #{method}          @name.#{method}        end      EOS    end  end   user = User.new(\"taro\")  puts user.upcase  ### 引用：[Rubyリファレンス：class_eval](https://ref.xaio.jp/ruby/classes/module/class_eval)eachでdowncase,upcaseを回し、downcase,upcaseを定義しています[:downcase, :upcase].each do |method|  class_eval <<-EOS    def #{method}      @name.#{method}    end  EOSend#{}で変数の値を埋め込んでいるので、downcaseの場合はこんな感じで定義されているということですclass_eval <<-EOS  def downcase    @name.downcase  endEOSつまり、特異クラスに対して、与えられたブロックをクラス定義の中のコードであるように実行することが出来るということですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で def class_eval を探してみます2. 該当箇所が1箇所だったので、それを見てみます1. activesupport > lib > active_support > core_ext > kernel > singleton_class.rb# frozen_string_literal: truemodule Kernel  # class_eval on an object acts like singleton_class.class_eval.  def class_eval(*args, &block)    singleton_class.class_eval(*args, &block)  endendこれを見てみるとsingleton_class.class_eval(*args, &block) を呼び出しているだけなので、このメソッドいるのかな？と思えてしまいますこちらがコミットログです  ruby1.9.2でsingleton_classが実装されたようですsingleton_class メソッドが記述されていたようです一応singleton_classの実装がRuby1.9.2で行われているかリポジトリのチェンジログ等で確認してみますRubyのGithubのdoc配下にNEWS-1.9.2があったので見てみると読んでみてclass_evalは使い方だけ覚えて使っていたけど、しっかり実装を追ってみたからこそわかることがあったので、引き続き続けていきます読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2018/01/11/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_ActiveSupport_class_eval%E7%B7%A8?utm_source=feed","isoDate":"2018-01-11T03:42:36.000Z","dateMiliSeconds":1515642156000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport try編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所Rails書いているとよく使う try を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますtry(*a, &b)Invokes the public method whose name goes as first argument just like public_send does, except that if the receiver does not respond to it the call returns nil rather than raising an exception.@person.try(:name)instead of@person.name if @person引用：Ruby on Rails API: tryレシーバ(@person)がnilならnilを返し、別のオブジェクトならnameメソッドを実行するというかんじですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で def try を探してみます2. 該当箇所が2個ほどあったので、それぞれみてみます1. activesupport > lib > active_support > core_ext > object > try.rbActiveSupport::Tryable.try# frozen_string_literal: truerequire \"delegate\"module ActiveSupport  module Tryable #:nodoc:    def try(*a, &b)      try!(*a, &b) if a.empty? || respond_to?(a.first)    endまず def try(*a, &b)を見てみます*aですが、rubyは仮引数に*をつけることで引数をすべて配列として受け取ることができます（可変長引数といいます）&b はブロックを引数として受け取ってますブロックとはeachメソッドなど、Rubyでは「ブロック」という仕組みを活用して、メソッドに「処理そのものを引数として渡す」というパターンが頻出します。Rubyの面白さを理解するためのメソッド、ブロック、Proc、lambda、クロージャの基本次に try!(*a, &b) if a.empty? を見てみると 仮引数のaが空の場合は try!(*a, &b) を実行するようですtry!を見てみます同じmodule内にtry!メソッドがありましたdef try!(*a, &b)  if a.empty? && block_given?    if b.arity == 0      instance_eval(&b)    else      yield self    end  else    public_send(*a, &b)  endend  if a.empty? && block_given? は配列aに対して empty? をしていますempty?メソッドは、配列が空であればtrue、1つ以上の要素があればfalseを返します。arr = [1, 2, 3]puts arr.empty?arr = []puts arr.empty?引用：Rubyリファレンス:empty?なので、配列の中身がnilでもfalseになりますblock_given? はメソッドにブロックが与えられているか確認するメソッドですメソッドにブロックが与えられていれば真を返します。Ruby2.4.0リファレンスマニュアルつまり、仮引数aの要素が空かつブロックが渡されているときがこちらの判定式の内容です※ ブロックについては@kidach1氏のこちらの記事が分かりやすかったですqiita.com次にif b.arity == 0を見てみますarity を調べてみるとメソッドが受け付ける引数の数を返します。-(必要とされる引数の数 + 1)を返します。C 言語レベルで実装されたメソッドが可変長引数を 受け付ける場合、-1 を返します。Ruby2.4.0リファレンスマニュアルブロックの引数が無い場合に真となりますinstance_eval にブロックを渡すということになりますinstance_evalメソッドは、渡されたブロックをレシーバのインスタンスの元で実行します。ブロックの戻り値がメソッドの戻り値になります。class Cat     def initialize(name)       @name = name     end     private     def hello       \"meow...\"     end  end  cat = Cat.new(\"Piko\")  puts cat.instance_eval { @name + \": \" + hello }  引用：Rubyリファレンス：instance_evalyield self はブロックが引数を受け取る場合を想定していますeach do |i|  puts iend次に if a.empty? && block_given?がfalseだった場合を見てみます public_send(*a, &b) を調べるとpublic_sendメソッドは、レシーバの持っているpublicなメソッドを呼び出します。引数や戻り値については、sendメソッドの説明をご覧ください。Rubyリファレンス：public_sendレシーバのpublicなメソッドに対してtry!で受け取った引数をそのまま渡していますtryメソッドに戻りますrespond_to?(a.first) を見てみます先程、tryの使い方を調べた際に出てきた例person.try(:name)でいうとaには[:name]が入っており、a.firstで :name が取れるので、respond_to?(:name) という感じですNilClass.tryclass NilClass  # Calling +try+ on +nil+ always returns +nil+.  # It becomes especially helpful when navigating through associations that may return +nil+.  #  #   nil.try(:name) # => nil  #  # Without +try+  #   @person && @person.children.any? && @person.children.first.name  #  # With +try+  #   @person.try(:children).try(:first).try(:name)  def try(*args)    nil  endnilに対してtryした場合は、常にnilを返すという動きですついでにnil.try!も見てみると# Calling +try!+ on +nil+ always returns +nil+.##   nil.try!(:name) # => nildef try!(*args)  nilendtryと同じ動きですtryが色々なオブジェクトで使えるのは、ActiveSupport::TryableモジュールをObjectにincludeしてからですclass Object  include ActiveSupport::Tryableclass Delegator  include ActiveSupport::Tryable読んでみてブロックを引き受けるメソッドを作る場合の書き方が非常に参考になったので、ここらへんは活かしていきたいと思います読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/27/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_ActiveSupport_try%E7%B7%A8?utm_source=feed","isoDate":"2017-12-27T02:27:06.000Z","dateMiliSeconds":1514341626000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport deep_dup編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所deep_dup を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみますRailsガイドのActive Supportコア拡張機能の 2.4 deep_dupの項目を見てみますdeep_dupメソッドは、与えられたオブジェクトの「ディープコピー」を返します。array     = ['string'] ['string'] ['string', 'another-string']# 1つ目の要素は複製されていないので、一方を変更するとどちらの配列も変更されるarray     # => ['foo'] ['foo', 'another-string']上で見たとおり、Arrayのインスタンスを複製して別のオブジェクトができたことにより、一方を変更しても他方は変更されないようになりました。array     = ['string'] ['string'] ['foo']オブジェクトが複製不可能な場合、deep_dupは単にそのオブジェクトを返します。number = 1 true引用：Active Supportコア拡張機能：2.4 deep_dupオブジェクトをコピーしたいが、別物として利用したい場合に利用するメソッドのようですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で def deep_dup を探してみます2. 該当箇所が3箇所だったので、それぞれみてみますactivesupport > lib > active_support > core_ext > object > deep_dup.rbObject.deep_dupclass Object  # Returns a deep copy of object if it's duplicable. If it's  # not duplicable, returns +self+.  #  #   object = Object.new  #   dup    = object.deep_dup  #   dup.instance_variable_set(:@a, 1)  #  #   object.instance_variable_defined?(:@a) # => false  #   dup.instance_variable_defined?(:@a)    # => true  def deep_dup    duplicable? ? dup : self  endendまずduplicable? かどうか判定しているようです※ duplicable?のソースコードリーディングについてはこちらshitake4.hatenablog.comtrueの場合は dup が実行されるようですRubyリファレンスのclone,dupで挙動を調べてみるとcloneメソッドとdupメソッドは、レシーバのオブジェクトのコピーを作成して返します。オブジェクトのコピーとは、同じ内容を持つ別のオブジェクトです。具体的には、元のオブジェクトと同じクラスの新しいオブジェクトで、元のオブジェクトのインスタンス変数を新しいオブジェクトにコピーしたものです。中略浅いコピーcloneとdupは「浅いコピー」を作ることに注意してください。Objectに対するdeep_dupは浅いコピーになるようですRubyリファレンスのclone,dupに記述している例をrails consoleで確認してみるとoriginalのnameも変わっていますArray.deep_dupclass Array  # Returns a deep copy of array.  #  #   array = [1, [2, 3]]  #   dup   = array.deep_dup  #   dup[1][2] = 4  #  #   array[1][2] # => nil  #   dup[1][2]   # => 4  def deep_dup    map(&:deep_dup)  endendレシーバに対してmapしています self.map(&:deep_dup)と同一です(&:deep_dup) の&:は配列の各要素に対して deep_dup を実行しています[1, 2, 3].map(&:to_s)=> [\"1\", \"2\", \"3\"]という感じです ※詳しい解説は@kasei-san氏のこちらの記事がわかりやすいかと思いますqiita.comということで、配列の各要素に対してdeep_dupをおこなっていますHash.deep_dupclass Hash  # Returns a deep copy of hash.  #  #   hash = { a: { b: 'b' } }  #   dup  = hash.deep_dup  #   dup[:a][:c] = 'c'  #  #   hash[:a][:c] # => nil  #   dup[:a][:c]  # => \"c\"  def deep_dup    hash = dup    each_pair do |key, value|      if key.frozen? && ::String === key        hash[key] = value.deep_dup      else        hash.delete(key)        hash[key.deep_dup] = value.deep_dup      end    end    hash  endendまず浅いコピーでレシーバをhashに入れていますeach_pair を調べてみるとeachメソッドは、ハッシュの要素（キーと値）の数だけブロックを繰り返し実行します。繰り返しごとにブロック引数にはキーkeyと値valが入ります。each_pairメソッドは、eachの別名です。Rubyリファレンス：each, each_pair (Hash)ということなので、レシーバのpairのkey,valueを取り出しています次にif key.frozen? && ::String === key  hash[key] = value.deep_dupを見ていきますfrozen? を調べてみるとfrozen?メソッドは、オブジェクトが凍結状態ならtrueを、そうでなければfalseを返します。オブジェクトを凍結状態にするには、freezeメソッドを使います。Rubyリファレンス：frozen?更に freeze を調べてみるとfreezeメソッドは、オブジェクトを凍結、つまり変更不可にします。凍結状態のオブジェクトを変更しようとすると、Ruby 1.8では例外TypeErrorが、Ruby 1.9では例外RuntimeErrorが発生します。Rubyリファレンス：freezefreezeされた状態 = 破壊的変更が出来なくなっているということのようですつまり if key.frozen? && ::String === key とは破壊的変更が出来ないStringクラスのキーの場合、valueのみをdeep_dupしていますそしてelse  hash.delete(key)  hash[key.deep_dup] = value.deep_dupendはkeyが破壊的変更が可能な値の為、key,valueともにdeep_dupしています読んでみてObjectでdeep_dupする場合は浅いコピーの為、気をつけなければいけないと思いました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/25/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_ActiveSupport_deep_dup%E7%B7%A8?utm_source=feed","isoDate":"2017-12-25T02:42:36.000Z","dateMiliSeconds":1514169756000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport duplicable?編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所Active Support コア拡張機能を見ていて知った duplicable? を今日は読んでみようと思いますどんな使い方だっけ？Railsを読んでみる前にまずは使い方を調べてみます2.3 duplicable?を読んでみるとRubyにおける基本的なオブジェクトの一部はsingletonオブジェクトです。たとえば、プログラムのライフサイクルが続く間、整数の1は常に同じインスタンスを参照します。1.object_id                 # => 3 3従って、このようなオブジェクトはdupメソッドやcloneメソッドで複製することはできません。true.dup  # => TypeError: can't dup TrueClasssingletonでない数字にも、複製不可能なものがあります。0.0.clone        # => allocator undefined for Float allocator undefined for BignumActive Supportには、オブジェクトがプログラム的に複製可能かどうかを問い合わせるためのduplicable?メソッドがあります。\"foo\".duplicable? # => true true false falseデフォルトでは、nil、false、true、シンボル、数値、クラス、モジュール、メソッドオブジェクトを除くすべてのオブジェクトがduplicable? #=> trueです。Active Support コア拡張機能：2.3 duplicable?dupメソッドやcloneメソッドで複製出来ない値が存在しているので、複製可能か確認する為の機能のようですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で def duplicable? を探してみます2. 該当箇所が10個ほどあったので、それぞれみてみますactivesupport > lib > active_support > core_ext > object > duplicable.rbObject.duplicable?class Object  # Can you safely dup this object?  #  # False for method objects;  # true otherwise.  def duplicable?    true  endend上記箇所のコミットログを見てみるとRuby2.4以前では NilClass, FalseClass, TrueClass, Symbol, Numeric はdup出来ませんでしたが、2.4から可能となったようです処理がどう変わったのか知りたいので、Ruby2.4.0のリファレンスを見てみますオブジェクトの複製を作成して返します。Ruby 2.4.0 リファレンスマニュアル：Object#cloneNilClass, FalseClass, TrueClass, Symbol, Numeric が複製ではなくインスタンス自身を返すようになったようです合わせて以前の挙動はどうだったのか、Ruby2.3.0のリファレンスを見てみますオブジェクトの複製を作成して返します。Ruby 2.3.0 リファレンスマニュアル：Object#cloneRuby2.3.0のバージョンだとレシーバが NilClass, FalseClass, TrueClass, Symbol, Numeric　の場合にTypeErrorが発生するという仕様だったんですね該当コミットgithub.comNilClass.duplicable?class NilClass  begin    nil.dup  rescue TypeError    # +nil+ is not duplicable:    #    #   nil.duplicable? # => false    #   nil.dup         # => TypeError: can't dup NilClass    def duplicable?      false    end  endendRuby2.4.0からレシーバ NilClass, FalseClass, TrueClass, Symbol, Numeric に対して dup/cloneが複製ではなくインスタンス自身を返すようになったため、オープンクラスする際にdupがTypeErrorを起こす（Ruby2.3.x以前のバージョンを使用している）場合に限りfalseを返すというようにしていますFalseClass.duplicable?class FalseClass  begin    false.dup  rescue TypeError    # +false+ is not duplicable:    #    #   false.duplicable? # => false    #   false.dup         # => TypeError: can't dup FalseClass    def duplicable?      false    end  endendこちらも同様ですTrueClass.duplicable?class TrueClass  begin    true.dup  rescue TypeError    # +true+ is not duplicable:    #    #   true.duplicable? # => false    #   true.dup         # => TypeError: can't dup TrueClass    def duplicable?      false    end  endendこちらも同様ですNumeric.duplicable?class Numeric  begin    1.dup  rescue TypeError    # Numbers are not duplicable:    #    #  3.duplicable? # => false    #  3.dup         # => TypeError: can't dup Integer    def duplicable?      false    end  endendこちらも同様ですComplex.duplicable?class Complex  begin    Complex(1).dup  rescue TypeError    # Complexes are not duplicable:    #    #   Complex(1).duplicable? # => false    #   Complex(1).dup         # => TypeError: can't copy Complex    def duplicable?      false    end  endendこちらも同様ですRational.duplicable?class Rational  begin    Rational(1).dup  rescue TypeError    # Rationals are not duplicable:    #    #   Rational(1).duplicable? # => false    #   Rational(1).dup         # => TypeError: can't copy Rational    def duplicable?      false    end  endendこちらも同様ですBigDecimal.duplicable?require \"bigdecimal\"class BigDecimal  # BigDecimals are duplicable:  #  #   BigDecimal.new(\"1.2\").duplicable? # => true  #   BigDecimal.new(\"1.2\").dup         # => #<BigDecimal:...,'0.12E1',18(18)>  def duplicable?    true  endendObjectと同様で常にtrueを返すようですMethod.duplicable?class Method  # Methods are not duplicable:  #  #  method(:puts).duplicable? # => false  #  method(:puts).dup         # => TypeError: allocator undefined for Method  def duplicable?    false  endendMethodは常にfalseを返すようですSymbol.duplicable?class Symbol  begin    :symbol.dup # Ruby 2.4.x.    \"symbol_from_string\".to_sym.dup # Some symbols can't `dup` in Ruby 2.4.0.  rescue TypeError    # Symbols are not duplicable:    #    #   :my_symbol.duplicable? # => false    #   :my_symbol.dup         # => TypeError: can't dup Symbol    def duplicable?      false    end  endendbeginからrescueまでのコードを見てみると Ruby 2.4.0において特定のシンボルはdup出来ないようですGithubで探してみると.to_sym.dup するとダメな文字列があったりするようです該当コミットgithub.com読んでみて普段使ってなかったメソッドだったのですが、調べてみることで、詳細な仕様が把握できたため、たまに使う時などにとてもハマるということはなくなりそうだなと思いました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/21/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_ActiveSupport_duplicable%3F%E7%B7%A8?utm_source=feed","isoDate":"2017-12-21T02:35:05.000Z","dateMiliSeconds":1513823705000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport presence編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所Rails書いているとよく使う presence を今日は読んでみようと思いますどんな使い方だっけ？Railsの日本語ドキュメントには記載がなかったので、APIリファレンスから確認してみます1. APIリファレンスでの探し方http://api.rubyonrails.org/ をブラウザで開くとページの左側にsearchがあるので、そこに presence を入力します2. 検索結果該当する項目があったため、クリックしてみると以下の説明がありましたpresence()object.present? ? object : nilFor example, something likestate   = params[:state]   if params[:state].present?becomesregion = params[:state].presence || params[:country].presence || 'US'APIリファレンスobject.present?の結果がtrueの場合は、objectそのものを返し、falseの場合は、nilを返すという仕様のようですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で presence を探してみます2. 該当箇所が1箇所だったので、それを見てみます1. activesupport > lib > active_support > core_ext > object > blank.rb# Returns the receiver if it's present otherwise returns +nil+.  # <tt>object.presence</tt> is equivalent to  #  #    object.present? ? object : nil  #  # For example, something like  #  #   state   = params[:state]   if params[:state].present?  #   country = params[:country] if params[:country].present?  #   region  = state || country || 'US'  #  # becomes  #  #   region = params[:state].presence || params[:country].presence || 'US'  #  # @return [Object]  def presence    self if present?  endメソッドの中身を見てみると、レシーバに対して present? しており、trueであればselfを返すようです最後に評価された値を返すという言語仕様な為、評価するものがなにも無い = nilということになります※ blank?メソッドのソースコードリーディングについてはこちらshitake4.hatenablog.com読んでみて丁寧なコメントが書いてあり、仕様や使い方が書いてあり非常に読みやすいと感じます読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/20/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_ActiveSupport_presence%E7%B7%A8?utm_source=feed","isoDate":"2017-12-20T02:36:42.000Z","dateMiliSeconds":1513737402000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport present?編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで以前書いた記事に読めるようにするまでの設定を画像キャプチャ付きで解説しましたので、よろしければこちらをご参照下さいshitake4.hatenablog.com読んだ箇所Rails書いているとよく使う present? を今日は読んでみようと思いますどんな使い方だっけ？読んでみる前にまずは使い方を調べてみます変数.present?, {}(空のハッシュ) のときにfalseを返します。Railsドキュメント：presentとのことですこちらも blank? 同様によく使うメソッドですソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で def present? を探してみます2. 該当箇所が1箇所なので、それをみてみますactivesupport > lib > active_support > core_ext > object > blank.rbclass Object  中略  # An object is present if it's not blank.  #  # @return [true, false]  def present?    !blank?  endblank?メソッドの返り値を否定演算子で評価していますtrue か false なので、present?も必ずtrue か false となります※ blank?メソッドのソースコードリーディングについてはこちらshitake4.hatenablog.com読んでみて今回は実装箇所が一箇所のみだったのとすでに blank? を読んでいたので、すんなりと理解することができました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/18/122011?utm_source=feed","isoDate":"2017-12-18T03:20:11.000Z","dateMiliSeconds":1513567211000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"3回以上やることは自動化したい | SRE-SET Automation Night | イベントレポート","contentSnippet":"2017年12月12日(火) SRE-SET Automation Nightのイベントレポートですイベント概要\"２回以上やることはなんでも自動化されるべきだ\" Adam Stone, CEO, D-ToolsCI/CDを用いたプロダクトリリースの自動化に関する経験Ansibleなどを用いたDevOpsの自動化AppiumやSeleniumなどのUIオートメーションツールを使った第一印象テストの自動化ハックとアドバイスCircleCI, Travis, BitriseなどのクラウドCIサービスの経験SeleniumやSlackbotを用いた日次タスクの自動化どなたでも発表やLTしていただけますのでぜひご参加ください。引用：[さらに増枠!] SRE-SET Automation Night「Data processing, workflow and us ~How to manage automated jobs~」Time 19:40-19:55Speaker @syu_cream 氏Slide概要BigQueryにログをアップロードする部分の話と統計情報を解析するコンポーネントの話でしたメルカリさんでは以前はこのような構成でログをBigQueryに送っていたようです※ fluentdFluentd | Open Source Data Collector | Unified Logging LayerFluentdとはどのようなソフトウェアなのか - たごもりすメモただcronジョブが失敗しやすくなったので、digdagでジョブ管理をしているようです※ digdagDigdag – Open Source Workflow Engine for the Multi-Cloud EraワークフローエンジンDigdagのまとめ #digdag - Qiita統計情報解析の話以前の構成はそこから Cloud Dataflowを使っているそうです※ Cloud Dataflowhttps://cloud.google.com/dataflow/Google Cloud Dataflow ってなんだ？ #Python - Qiita※ scioGitHub - spotify/scio: A Scala API for Apache Beam and Google Cloud Dataflow.また apache airflowも試しているとこのことでした※ apache airflowApache AirflowSIOS Tech. Lab - エンジニアのためになる技術トピックスapache airflowを使って以下のようなメリットがあったようです- ジョブとジョブの依存関係を管理出来る- データ・ソースの待機が出来る「レビューのコストを削減するための施策」Time 19:55-20:10Speaker @tarappo 氏概要レビューのコストが課題としてあったそうですレビューサポートツールとしてDangerを使い文書チェックツールでtextlintを使っているそうです※ DangerGitHub - danger/danger: 🚫 Stop saying \"you forgot to …\" in code review (in Ruby)Dangerで始めるPull Requestチェック自動化 - コネヒト開発者ブログ※ textlintGitHub - textlint/textlint: textlint is the pluggable linter for natural language text.textlintで日本語の文章をチェックする | Web Scratch「After Test Automation, 自動テスト後」Time 20:10-20:25Speaker @vbanthia 氏Slide    Reliable mobile test automation  from Vishal Banthia 概要モバイルのE2Eテストがflaky（テストが失敗する場合が色々ありすぎる）、実行環境による失敗等でメンテされずゴミ箱行きが多い※ flakyflakyについては，このセッションも参照になる。[Your Tests Aren’t Flaky, You Are! | Richard Bradshaw] https://t.co/mm5u9QtGZy #automation_night— Mark Ward (@mkwrd) 2017年12月12日   記録する対象はrspec_html_reporterでレポートを出力しているそうです※ rspec_html_reporterGitHub - vbanthia-zz/rspec_html_reporter: Rspec custom formatter to produce beautiful reports from rspecLT「Magic Podの活用を具体的に考えてみた」Time 20:30-20:35Speaker 戸田広　氏Slide    Magic Podの活用を具体的に考えてみた @ SRE-SET Automation Night  from Hiroshi Toda 「Prometheusを導入した話」Time 20:35-20:40Speaker 株式会社Nagisa 榎戸　氏「セキュリティ強化のための自動化」Time 20:40-20:45Speaker @manabusakai (freee 株式会社) 氏Slide「1人インフラ運用チームで、自動化の作業時間を確保するためにやっていること」Time 20:45-20:50Speaker 北野勝久（ @katsuhisa__ ）氏Slide「TBD」Automation基盤の提供の仕方Time 20:50-20:55Speaker @tnir　氏所感第二回も開催するそうです#automation_night— Yoshiki Ito/伊藤由貴 (@yoshikiito) 2017年12月12日   第2回もあるそうなので、是非またいきたいですTwitterハッシュタグ#automation_nightTogettertogetter.com読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/13/2%E5%9B%9E%E4%BB%A5%E4%B8%8A%E3%82%84%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E8%87%AA%E5%8B%95%E5%8C%96%E3%81%97%E3%81%9F%E3%81%84_%7C_SRE-SET_Automation_Night_%7C_%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88?utm_source=feed","isoDate":"2017-12-13T01:46:59.000Z","dateMiliSeconds":1513129619000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Railsのソースコード読んでみる | ActiveSupport blank?編","contentSnippet":"普段仕事で使っているRuby on Railsですが、ソースコードを読む機会もなかなかないので、試しにやってみることにしました読めるようにするまで1. Githubのrails/railsリポジトリから任意のフォルダにクローンするブラウザで https://github.com/rails/rails　を開くClone or Downloadをクリッククリップボードアイコンをクリック任意のディレクトリ配下で $ git clone https://github.com/rails/rails.git rails2. 任意のエディタで閲覧僕の場合はRubyMineを使ってますRubymineを開き、openを選択先程cloneした任意のフォルダを選択する下記のように取り込めている読んだ箇所Rails書いているとよく使う blank? を今日は読んでみようと思いますどんな使い方だっけ？読んで見る前に使い方を調べてみますRailsの日本語ドキュメントを見てみると 変数.blank?nil? + empty? のようなメソッド。nilまたは空のオブジェクトをチェックできる。, {}(空のハッシュ) のときにfalseを返します。Railsドキュメントざっくり値がないものを確認したいときとかに便利ですね。ruby標準でも欲しいなと思ったりしますソースコードを読んでみる1. railsプロジェクトのactivesupportにある機能なので、activesupportディレクトリのlib配下で def blank? を探してみます2. 該当箇所が10個ほどあったので、それぞれみてみます1. activesupport > lib > active_support > core_ext > date > blank.rb# frozen_string_literal: truerequire \"date\"class Date #:nodoc:  # No Date is blank:  #  #   Date.today.blank? # => false  #  # @return [false]  def blank?    false  endendDateクラスに対してblank?をすると必ずfalseが返り値のようです※ オープンクラスとは？既存するクラスを好きな場所で再オープンし、メソッド修正・追加など任意の変更を加えられる機能のこと。 [Ruby] メタプログラミングの入り口、オープンクラスを理解する2. activesupport > lib > active_support > time_with_zone.rb中略# An instance of ActiveSupport::TimeWithZone is never blankdef blank?  falseend中略ActiveSupport::TimeWithZoneの場合も同じように必ずfalseが返り値のようです3. activesupport > lib > active_support > core_ext > date_time > blank.rb# frozen_string_literal: truerequire \"date\"class DateTime #:nodoc:  # No DateTime is ever blank:  #  #   DateTime.now.blank? # => false  #  # @return [false]  def blank?    false  endendDateTimeクラスに対してblank?をすると必ずfalseが返り値のようです4. activesupport > lib > active_support > core_ext > object > blank.rbObject.blank?# An object is blank if it's false, empty, or a whitespace string.# For example, +false+, '', '   ', +nil+, [], and {} are all blank.## This simplifies##   !address || address.empty?## to##   address.blank?## @return [true, false]def blank?  respond_to?(:empty?) ? !!empty? : !selfendrespond_to?の使い方を調べてみるとrespond_to?メソッドは、レシーバのオブジェクトに対してメソッドを呼び出せるかどうかを調べます。引数nameにはメソッド名をシンボルか文字列で指定します。メソッドnameを持っていればtrue、なければfalseが返ります。Rubyリファレンス:respond_to? (Object)empty?が実装されているかチェックしているようです!!empty?　で falseの場合は !selfが返りますなぜempty?の前に!!が付いているのかわからなかったので、更に調べてみます該当箇所のコミットログを見てみると126dc47で変更しているようですgithub.comコントリビューターから質問されているところを見つけましたrubyという言語仕様上empty?が書き換えられて必ず TrueClass / FalseClass のシングルトンが返り値となるわけではない為、こういう書き方をしているようです!self はObjectクラスのインスタンスに対して行っているので、基本的にfalseが返り値となりますNilClassclass NilClass  # +nil+ is blank:  #  #   nil.blank? # => true  #  # @return [true]  def blank?    true  endendDateクラスのときと同じようにオープンクラスしてblank?メソッドを追加しているようですFalseClassclass FalseClass  # +false+ is blank:  #  #   false.blank? # => true  #  # @return [true]  def blank?    true  endendTrueClassclass TrueClass  # +true+ is not blank:  #  #   true.blank? # => false  #  # @return [false]  def blank?    false  endendStringBLANK_RE = /\\A[[:space:]]*\\z/# A string is blank if it's empty or contains whitespaces only:##   ''.blank?       # => true#   '   '.blank?    # => true#   \"\\t\\n\\r\".blank? # => true#   ' blah '.blank? # => false## Unicode whitespace is supported:##   \"\\u00a0\".blank? # => true## @return [true, false]def blank?  # The regexp that matches blank strings is expensive. For the case of empty  # strings we can speed up this method (~3.5x) with an empty? call. The  # penalty for the rest of strings is marginal.  empty? || BLANK_RE.match?(self)endレシーバがempty?またはBLANK_REにマッチする場合はtrueのようですBLANK_RE = /\\A[[:space:]]*\\z/※以前の記事でPOSIX文字クラスについて調べています上記2パターンのどちらかにマッチした場合にtrueが返り値になるようですNumericclass Numeric #:nodoc:  # No number is blank:  #  #   1.blank? # => false  #   0.blank? # => false  #  # @return [false]  def blank?    false  endendNumericの場合も必ずfalseが返り値のようですTimeclass Time #:nodoc:  # No Time is blank:  #  #   Time.now.blank? # => false  #  # @return [false]  def blank?    false  endend読んでみてソースコードを読むのは結構億劫だったりしますが、よく使う処理などは意外な発見があったりして楽しめそうです読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/12/Rails%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B_%7C_ActiveSupport_blank%3F%E7%B7%A8?utm_source=feed","isoDate":"2017-12-12T07:26:58.000Z","dateMiliSeconds":1513063618000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"SEOサーチニーズマーケティングとSNS潜在ニーズマーケティングでwebを制する 〜Webには探されている情報と探されていない情報がある〜 | イベントレポート","contentSnippet":"最近はWebマーケティングにも興味が出てきていてサービスをもっとユーザーに使ってもらえるにはどうすればいいのだろうか？概要2017年12月6日（水）開催の SEOサーチニーズマーケティングとSNS潜在ニーズマーケティングでwebを制する 〜Webには探されている情報と探されていない情報がある〜のイベントレポートです公演内容はじめにwebには探される情報と探されない情報がある探される情報のwebマーケティングとは？探されていない情報のwebマーケティングとは？はじめに　Time 15:00-15:05Speaker ティネクト株式会社 楢原一雅氏テーマはサーチニーズマーケティングSNSでのバズる記事について1.webには探される情報と探されない情報があるTime 15:05Speaker ティネクト株式会社 楢原一雅氏Webでの情報の分類大きく2つに分けることができる探されていない情報まだサービス認知がなかったり、検索する利用習慣がないもの探されている情報Googleで検索される情報と同義探されている情報 = 検索ニーズであり、検索ニーズはマーケティングに活かすことが出来る探されていない情報がユーザに届くまでの経路ユーザがスマホを開くFacebook等SNSをなんとなく見ていて他者が「いいね！」しているもので気になったものを見る2.探される情報のwebマーケティングとは？Time 15:12-15:40Speaker 株式会社 電通 倉増京平氏サーチニーズマーケティングとは？ウェブサイトへアクセスされるワードとサーチエンジンで検索されるワードを最適化すること特徴サイトへのアクセスとは切り離し、市場でのニーズ把握・分析の手段として利用することも出来るサーチニーズマーケティングの基本的な考え方横軸：ウェブサイトへのアクセスキーワード縦軸：サーチエンジンでの検索ワード＼  サーチワード少ない  サーチワード多いアクセスワード多い  C  Aアクセスワード少ない  D  BAのエリア検索数→アクセス数ともに多く、サーチニーズマーケティングが上手くいっていると考えられるBのエリア検索数は多いがアクセスが少ない。いわゆる「取りこぼしている」マーケットと言えるCのエリアキーワードごとのコンバージョンを見て、高い場合はロングテールでの集客獲得に成功している。低い場合は無駄なアクセスを呼び込んている可能性があるDのエリア優先順位は低いが、ロングテールの優良キーワードが漏れていたり、市場の先行指標となりうるキーワードが隠れていることもある。要注意エリアサーチニーズマーケティングを実施する場合にまず取り組むことBのエリアのものをAに引き上げる調査手法アドワーズのキーワードツールで自社の関連検索キーワードを抽出し、検索数が多いワードほどユーザが求めている（= ニーズがある）と言える調査例1. アクセスワード  - 100ワード  - サイトカタリストのデータを用いる2. ニーズワード  - 300ワード  - Googleの月間平均検索回数  - 無関係ワードの削除など調整・精査を行いますアクセスワードとニーズワードを同数でとる場合などもありますが、今回は1. 集客力アップのためニーズキーワードをより広範に調べるため2. アクセスキーワードの中にはニーズが弱いロングテールワードが多いという点から、アクセスワードの3倍のニーズワードを調査しました3.探されていない情報のwebマーケティングとは？Time 15:41- 16:45Speaker ティネクト株式会社 楢原一雅氏情報を得る方法がスマホの登場によって変化した以前のニュースの見方読売新聞を見る→各記事を見る最近のニュースの見方SNSやスマホでの通知などで様々な媒体からニュースが直接送られてくるそこで、SNSマーケティングの必要性が出てきたSNSでバズるには？バズるための要素とは？メディア力配信力発行部数アプリDL数SNSフォロワーなどSEO検索される情報をもっているコンテンツ力（記事力）　SNSはファンを作るPVを伸ばすは意識しないファンとはあなたの隣に座っている人です（身近な人向けに響く記事を書こう）自分の身近な人にバズらないとダメなぜなら友人→友人の友人→同じ価値観の人という連鎖でSNSでは伝搬していくからコンテンツ力（記事力）とは？共感する役立つ笑える（泣ける）上記3つを満たす記事であることそれぞれの感情によってシェアされるSNSが変わる共感する内容はFacebook(いいね！)役立つ内容ははてなブックマーク（ブックマーク）笑える（泣ける）内容はTwitter（リツイート）という傾向があるつまりではWeb上での面白いとは？ブログが面白さを表現している最たる例    - 個人の思い込みや主張思想が、むき出しになっていることが面白さではないか？みんなが興味あるテーマと主張したいことが一致していることがバズる記事！探されていない情報のwebマーケティングとはメディア力と記事力を磨くこと読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/12/07/%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88_%7C_SEO%E3%82%B5%E3%83%BC%E3%83%81%E3%83%8B%E3%83%BC%E3%82%BA%E3%83%9E%E3%83%BC%E3%82%B1%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0?utm_source=feed","isoDate":"2017-12-07T01:30:25.000Z","dateMiliSeconds":1512610225000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"監視って何？という初心者にオススメ | ソフトウェアエンジニアのための ITインフラ監視[実践]入門 | 書評","contentSnippet":"オススメ理由と概要監視って何？どんなことするの？という知識ゼロの状態から監視する対象がどういうものがあるのかどうやってアラートの対象にするのか実際に運用する場合はどうすればいいのかといった内容が網羅的に書かれており、監視の入門書として最適だったなと思いました私と同じようにITインフラ監視に関して知識があまりない。これから学んでいきたいというエンジニアの方にはオススメだと思います章立て第1章 監視の目的第2章 設計の流れ第3章 現状分析第4章 判断基準の設計第5章 監視サーバの選択と経路の設計第6章 監視業務運営の設計第7章 構築第8章 運用に入ったあとの問題への対処第9章 自動化を見据えてポイントを抜粋1. どんなレイヤーがあるの？まず、監視を行う項目を棚卸ししやすいよう、5つのレイヤーに分けて分類します。レイヤーは5つに分けていて、以下の分類だそうです外形アプリケーションデーモン（ミドルウェア）リソースサーバ2. 監視閾値の決め方すべての監視項目の決定時に求められるのが、 測定方法と監視閾値です。 これらはどのような基準で決めていけばよいのでしょうか？ また、閾値に達した、すなわち障害発生と認識する際に必要となる情報とは何でしょうか？監視する対象が決まっても、何を監視して通知するための基準はどうすればいいのかも気になるところだと思います3回の測定で連続して監視閾値に達した際に通知することのように設定するとのことです3. アプリケーションの基準監視項目名   内容   対象   注意値    警告値監視専用APIの参照   サービスの動作確認   Webアプリケーション   3秒   7秒監視専用ページの参照   サービスの動作確認   Webアプリケーション   3秒   7秒アプリケーションログの監視   サービスの異常検知   Webアプリケーションログ   -    ある引用：4.4 アプリケーションの基準4. ミドルウェアの基準監視項目名   内容   対象   注意値   警告値プロセス数   プロセスの死活確認   ミドルウェアのプロセス   -   0応答   応答時間の確認   ミドルウェアのポート   通常時の2倍   通常時の3倍引用：4.5 ミドルウェアの基準感想上記の他にも重要度をどうやって決めていけばいいのか。実際の監視業務の運用はどうすればいいのかなどが書かれていて、監視について何も知らない人が全体像をつかむのには最適な本ではないかと思います書籍名：ソフトウェアエンジニアのための ITインフラ監視[実践]入門 (Software Design plus)著者：斎藤 祐一郎","link":"https://blog.shitake4.tech/entry/2017/12/01/%E7%9B%A3%E8%A6%96%E3%81%A3%E3%81%A6%E4%BD%95%EF%BC%9F%E3%81%A8%E3%81%84%E3%81%86%E5%88%9D%E5%BF%83%E8%80%85%E3%81%AB%E3%82%AA%E3%82%B9%E3%82%B9%E3%83%A1_%7C_%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6?utm_source=feed","isoDate":"2017-12-01T07:55:06.000Z","dateMiliSeconds":1512114906000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"OSS開発参加の為に一歩踏み出してみた | OSSGate | イベントレポート","contentSnippet":"経緯以前からOSS開発に参加したいな〜とは思っていたけれど、バグ踏むことあんまりないな〜とかちゃんとした英文書いたりとかしなきゃいけないよな〜とか参加することに非常に高いハードルを感じていましたDoorkeeperでOSS Gateを見つけましたOSSGateとは？oss-gate.github.ioこれからOSS開発に参加したいなと思っている人が始める心理的ハードルを低くする為のコミュニティのようだったので、まさしく自分が求めているものだ！と思い今回参加してみました。コミュニティについて「OSS Gate」とはOSS開発に参加していない人が参加する人に変わる「入り口」を提供する取り組みです。OSS GateOSSGateでは- ワークショップ- ミートアップがあって、ワークショップは初心者向け、ミートアップは一度参加した人が継続的にOSS活動していくためのもののようですワークショップの概要ワークショップではOSSの開発に参加する人をビギナーサポーターレポーターと分類するそうです「ビギナー」とは次のような人ですOSSの開発に参加したいけどまだ参加したことがない人OSSの開発に参加したことはあるけどまだ自信がない人参加したい！という人は「ビギナー」として申し込んでください　　「サポーター」とは次のような人ですOSSの開発に参加している人（OSSの開発に参加していれば「OSS Gateワークショップ」未経験でも大丈夫です。）「ビギナー」をサポートしたい！という人は「サポーター」として申し込んでください(サポーターは、従来のOSS Gateワークショップで「メンター」と呼んでいた人たちです)「レポーター」とは次のような人です。http://oss-gate.github.io/ にイベントレポートを書く人サポーターではない形でのOSS Gateへの参加方法を考えていた人イベントレポート例：OSS Gateワークショップ2016-06-11開催レポートこのレポートはワークショップの内容を時系列で並べたものになっていますが、内容も分量も違うまとめ方も試行錯誤の段階です。内容や分量などを相談しながらまとめていきましょう。当日は、ワークショップの内容は実施せず、ビギナー・サポーターを観察したりインタビューしたりしながら随時レポートをまとめたり、レポートに入れる材料を収集します。ということで今回はビギナー（初参加）として申し込みしましたOSSGateワークショップ当日今回参加したのはOSS Gate東京ワークショップ2017-11-25です当日は10時30からワークショップがスタートしOSSGateの説明や準備、OSS開発手順など説明を受けましたそして今回取り組んでみたいOSSを選択してという感じですその後はworkshop内にissueを立てて、どんなことをやったのか作業ログを記述していくという感じでしたgithub.com作業ログはOSSを使用するユーザとして、ドキュメントに沿ってインストールすることで、わかりにくいところ、はまったところなどを主に書いていく感じです　　そのつまづきはドキュメントにどう書いてあったら解消されただろうかを今回はプルリクとして作成しましたわからないところなどは隣にサポータの方がいたので相談したりして進めていくことで特に躓くところもなく順調に進めましたOSSへ初プルリク— しいたけ (@shitake4) 2017年11月25日   感想OSS開発に参加するということははかっこよくバグフィックス出したりするものだと思い込んでたけど、ユーザー目線で見た時にこういうドキュメントの方がいいんじゃないってフィードバックするということも参加方法のひとつとして学べたことが非常に大きかったです読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/11/27/OSS%E9%96%8B%E7%99%BA%E5%8F%82%E5%8A%A0%E3%81%AE%E7%82%BA%E3%81%AB%E4%B8%80%E6%AD%A9%E8%B8%8F%E3%81%BF%E5%87%BA%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F?utm_source=feed","isoDate":"2017-11-27T02:31:06.000Z","dateMiliSeconds":1511749866000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Rails Developers Meetup #7を見てみました | イベントレポート","contentSnippet":"2017年11月16日(木) Rails Developers Meetup #7のイベントレポートです。当日はリモートから参加させて頂きました！#railsdm　リモート着席— しいたけ (@shitake4) 2017年11月16日   イベント概要第一線で活躍する開発者・導入企業から、RubyやRailsに関する発想・アプローチ・成功体験・失敗体験を学ぶ、非営利勉強会です。RailsでECサービスをゼロから作ってみてTime 19:35〜20:05Speaker 株式会社spice life 赤松 祐希 氏Slide概要オリジナルTシャツ販売サービス「STEERS」の内部の設計や開発で得た知見・経験について話します。発表ではチーム開発においてプロダクトマネージャーとエンジニアの意思疎通の大事さとそこをspice lifeさんはどうやって取り組んだのか。Rails開発において原則を守っていくことの大事さと開発時にどういったことを考え開発していたのかを学ぶことができましたspice lifeさんでは以下のようなチーム構成と特色をもっているようですチーム構成プロダクトマネージャー兼アプリケーションエンジニアインフラ兼アプリケーションエンジニアデザイナチームの特色プロダクトマネージャーと開発者が同一人物 メリットとして、意思疎通のコストがかからない 多くのプロジェクトではプロダクトマネージャとエンジニアが別れているケースが多いと思いますが、プロダクトマネージャーと開発者が別の場合は認識違いが発生するというのは非常に共感しましたただ仕様変更も発生するし、すべてがスムーズにいくわけではないとのことですRailsの話では開発時に考えておきたい必要なことを発表されていました- データベース設計をどうするべきか- マイグレーションをどうするべきか- サービスレイヤをどうするべきか- フォームクラスを利用する場合の、バリデーションをどこに書くのかetcQARails原則はどうやって学びましたか？本ですエリック・エヴァンスのドメイン駆動設計オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方スタートアップでのRails開発/運用でやってよかったことTime 20:05〜20:20Speaker 株式会社トレタ 沢田 洋平 氏Slide概要トレタ社では飲食店向けの予約/顧客管理サービスをつくっています。開発に集中していく為にいかに運用を整備して、回していくかというのが勉強になりました。そのためにどういう部分を整備するのがあまり手間をかけずに運用が楽になっていくのかを発表されていましたスタートアップの特徴プロダクト開発に集中するため、運用がまわらなくなってしまう。そのため、合間に地道に運用面を整備する必要があるあまり手間をかけずに運用を楽にする方法リクエストのログが構造化されておらず検索性が低い為、アプリケーション固有のリクエストログの作成リクエストのログを集めて貯める為に、BigQueryを使用ジョブキューのログもリクエストログを同じくらい大事なためしっかりと収集リクエストに比べて処理時間がユーザ体験に直結しないので見過ごしがちグローバルサービスを作る時に考えておくことTime 20:20〜20:35Speaker 株式会社トレタ 中村 真人 氏Slide概要トレタは日本以外でも、シンガポールや台湾など15ヶ国以上の飲食店で使われています。タイムゾーンを考慮したRailsアプリケーション開発と海外対応の事例について発表されておりました。DBにタイムゾーン文字列を保存する際の注意点やRailsアプリで日時を扱う場合のおすすめケース別使用例トレタさんでの祝日対応もサービスならではの特徴があり非常に学びがありましたSMSの利用用途では以下のものがあるため、なるべく国番号（例：+81(日本)）を入れるようにしていたのもグローバルサービスならではと感じましたクックパッドでの Webアプリケーション開発 2017Time 20:45〜21:15Speaker クックパッド株式会社 鈴木 康平 氏Slide概要クックパッドではこれまで Microservices 化を推し進め、1つの巨大な Rails アプリを大勢で開発するのではなく、いくつもの小さいアプリを小さいチームで開発しようとしてきました。クックパッドさんでのwebアプリケーション開発における自動化Hakoでの学びですデプロイフローHakoが作れれた経緯Hakoが出来たことによって新規webアプリケーションの開発フローが以下のようにしかし課題感はまだのこっていたため統合コンソールの開発(hako-console)したそうです。それによって開発フローが変化したとのことでしたまた今後やっていきたいこととして以下に取り組んでいるそうですサービスメッシュRPCコンテナは友だち！ in Rails Developers MeetupTime 21:15〜21:45Speaker GMOペパボ株式会社 近藤 宇智朗 氏Slide概要いわゆるコンテナ仮想化と呼ばれるものは、正体はホストOSからリソース、権限等を隔離・制限したプロセスです。皆さんは隔離されていますか？途中で離席してしまったため、メモを残せず。。まとめ定期開催は今回が最後とのことで残念ではありますが、また参加させて頂きたいと思います。初のリモートの参加でしたが、不自由なく非常に便利だったため、また開催するときには利用してみたいですtogetter.com読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/11/17/%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88%EF%BC%9ARails_Developers_Meetup_%237?utm_source=feed","isoDate":"2017-11-17T02:23:40.000Z","dateMiliSeconds":1510885420000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":" [:blank:][:alnum:]ってなんだろう | rails commit log流し読みを読んでみた","contentSnippet":"概要y_yagiさんのrails commit log流し読みを読んでいてわからなかったこと調べてみましたy-yagi.hatenablog.comわからなかったことPOSIX文字クラスPOSIX文字クラスgithub.comの :word: という記述を初めてみましたUnicodeプロパティと 似た機能を持つ記法として、POSIX 文字クラスと呼ばれるものがあります。 これらは上の省略記法とは異なり、文字クラスの中でしか用いることが できません。これらは [:クラス名:] という記法を持ちます。 また、[:^クラス名:]という記法でその否定を意味します。 以下の括弧では実際にどの文字にマッチするかが Unicode プロパティや Unicode コードポイントで示されています。https://docs.ruby-lang.org/ja/latest/doc/spec=2fregexp.html種類は以下のものがあります文字説明[:alnum:]  英数字 [:alpha:]  英字 [:ascii:]  ASCIIに含まれる文字 (0000 - 007F) [:blank:] スペースとタブ [:cntrl:] 制御文字 [:digit:] 数字 (Decimal_Number)[:graph:]  空白以外の表示可能な文字(つまり空白文字、制御文字、以外) [:lower:]  小文字 [:print:]  表示可能な文字(空白を含む)[:punct:] 句読点 [:space:] 空白、改行、復帰 [:upper:]  大文字 [:xdigit:]  16進表記で使える文字 [:word:] 単語構成文字 Rubyのバージョンによって挙動が変わったりすることもあるみたいですqiita.com","link":"https://blog.shitake4.tech/entry/2017/10/18/%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F_-_rails_commit_log%E6%B5%81%E3%81%97%E8%AA%AD%E3%81%BF%282017/08/03%29?utm_source=feed","isoDate":"2017-10-18T00:24:58.000Z","dateMiliSeconds":1508286298000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Mackerel Dayでわからないこと調べてみた(freeeでMackerelを使って一年間サービスを運用してみた事例紹介)","contentSnippet":"概要Mackerel Dayに行ってきたのですが、用語とかがわからなくてイマイチ理解が進まなかったものなど、自分が分からなかったものを調べてみました第三弾ですイベントレポートはこちらshitake4.hatenablog.com分からなかったことBugsnagDeep Security as a Service for AWSPagerDuty対象セッションTitle freeeでMackerelを使って一年間サービスを運用してみた事例紹介Time Time 16:00〜16:20Speaker freee 浅羽 様1. Bugsnag調べてみた結果www.bugsnag.com主にはモバイルアプリのクラッシュログなどのログ管理に関して、最近の流れを知りたいと思いいろいろ物色してみました。類似サービスとしてはCrashlyticsなんかがありますが、いろいろ使っていると機能的に柔軟性が足りなかったりして目的に沿った利用ができないことが増えてきて、他に手頃なサービスあるのかなと思ったことも要因です。https://kazucocoa.wordpress.com/2015/02/12/bugsnag%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F%E3%81%8C%E3%80%81%E8%89%AF%E3%81%95%E3%81%9D%E3%81%86%E3%81%A0/エラーをGithubのissueで管理したりと多彩な機能があるログ収集サービスみたいです。2. Deep Security as a Service for AWS調べてみた結果WS上の仮想マシンに、Deep Security エージェントをインストール。6つのセキュリティー機能で仮想マシンの多層的な防御を可能にします。特に侵入防御（IPS/IDS)機能に関しては、WindowsだけでなくLinux, Solaris等などの幅広いサーバーOSに対応し、さらに100以上のアプリケーションの脆弱性も保護することができます。https://licensecounter.jp/trendmicro/aws/AutoScalingにも対応していて、サーバの増減に合わせて自動的にセキュリティ対策できるのは便利そうだと思いました3. PagerDuty調べてみた結果www.pagerduty.comPagerDuty -  https://www.pagerduty.com/ アプリ、サーバ等からの通知をきっかけに、予め定義していたエスカレーションポリシーとスケジューリングに基いて様々なアクションを実行することができるSaaSです。http://blog.serverworks.co.jp/tech/2015/10/13/start-pagerduty/IFTTTみたいな感じですかね。サーバからの通知で何かアクションを実行するというのを自動化したりしたいときに便利そうです読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/10/13/Mackerel_Day%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F%28freee%E3%81%A7Mackerel%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E4%B8%80?utm_source=feed","isoDate":"2017-10-13T01:36:54.000Z","dateMiliSeconds":1507858614000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Mackerel Dayでわからないこと調べてみた（Mackerel インフラ基盤 AWS 移行の舞台裏）","contentSnippet":"概要Mackerel Dayに行ってきたのですが、用語とかがわからなくてイマイチ理解が進まなかったものなど、自分が分からなかったものを調べてみましたの第二弾ですイベントレポートはこちらshitake4.hatenablog.com分からなかったこと時系列データベースRedis ClusterシャードUnboundコンテンツサーバとキャッシュサーバvpcのリゾルバTTL60iptablesのチェイン対象セッションTitle Mackerel インフラ基盤 AWS 移行の舞台裏Time 15:00〜15:20Speaker はてな 大野　様1. 時系列データベース調べてみた結果そもそも時系列データ・時系列データベースとは？timestamp1,key,value1  timestamp2,key,value2  timestamp3,key,value3  :  時系列データベースとは、上記のような時系列データの保存・処理に特化したデータベースです。 Web インフラストラクチャーの文脈では、サーバのメトリクス等が時系列データにあたります。http://techlife.cookpad.com/entry/timeseries-database-0012. Redis Cluster調べてみた結果Redis Cluster 機能を使うと、Redis インスタンスをクラスタリングすることができる。https://qiita.com/key-amb/items/c3c947578b043a6b40963. シャード調べてみた結果シャード (API/CLI: ノードグループ) は、1 〜 6 個の Redis ノードで構成されるコレクションです。Redis (クラスターモードが無効) クラスターを構成するシャードは 1 つに限られます。Redis (クラスターモードが有効) クラスターは 1 から 15 個のシャードで構成できます。クラスターのデータは、クラスターのシャード間で分割されます。シャードに複数のノードがある場合、1 つを読み書きのプライマリノード、その他を読み取り専用のレプリカノードとするレプリケーションが実装されます。http://docs.aws.amazon.com/ja_jp/AmazonElastiCache/latest/UserGuide/Shards.html4. Unbound調べてみた結果UnboundはBINDの代替を目指したDNSキャッシュサーバです。 2008年5月20日に正式版1.0がリリースされました。 オープンソースのソフトウェアとして公開されており，ライセンスはBSDライセンスです。 UnboundはNLnet Labsにより開発と保守が行われています。http://gihyo.jp/admin/feature/01/unbound/0001スライド調べてみたから若干脱線しますが、DNSコンテンツサーバとDNSキャッシュサーバがそれぞれどんな役割なのかよくわからなかったので、さらに調べてみました5. コンテンツサーバとキャッシュサーバさて、このDNSサーバさんですが、大きく分けて二種類あります。http://wa3.i-3-i.info/diff10dns.htmldnscacheうまく調べられなくてわかってないです。dnsmasqうまく調べられなくてわかってないです。6. vpcのリゾルバ調べてみた結果VPCAmazon Virtual Private Cloud (Amazon VPC) により、アマゾン ウェブ サービス (AWS) クラウドの論理的に分離したセクションをプロビジョニングできます。これにより、AWS リソースをユーザー定義の仮想ネットワークで起動できますhttps://aws.amazon.com/jp/vpc/リゾルバドメイン名を元にIPアドレス情報を検索したり（正引き）、IPアドレスからドメイン名の情報を検索したり（逆引き）するのが目的である。名前解決を行うことから「解決するもの」（resolver）という意味でリゾルバと呼ばれているhttp://www.weblio.jp/content/%E3%83%AA%E3%82%BE%E3%83%AB%E3%83%90これまでWebブラウザがDNSサーバーにIPアドレスを問い合わせると説明してきたが，正確に言うと，IPアドレスを問い合わせるのはWebブラウザなどのアプリケーションに含まれる「リゾルバ」と呼ばれるプログラムである。http://itpro.nikkeibp.co.jp/article/COLUMN/20071022/285173/ブラウザ等アプリケーションにリゾルバが含まれていて、リゾルバがDNSサーバーに問い合わせにいくという流れみたいです7. TTL60調べてみた結果DNSでは、Authoritative name server が特定のリソースレコードに対してTTLを設定する。（再帰的な）キャッシングネームサーバが Authoritative name server にリソースレコードについて問い合わせたとき、（再帰的な）キャッシングネームサーバはTTLによって指定される時間（秒単位で）の間その記録をキャッシュするhttps://ja.wikipedia.org/wiki/Time_to_liveTTL60はキャッシュの保持期間が60秒って意味っぽいです8. iptablesのチェイン調べてみた結果iptablesは複数のチェックポイント(チェインと呼ぶ)ごとにパケットの通過を許可、拒否、破棄する条件を設定できます。https://qiita.com/fusagiko/items/bc2e9ae9392a28b73734     読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/10/12/Mackerel_Day%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F%EF%BC%88Mackerel_%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E5%9F%BA%E7%9B%A4?utm_source=feed","isoDate":"2017-10-11T23:58:23.000Z","dateMiliSeconds":1507766303000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Mackerel Dayでわからないこと調べてみた（Mackerelリリース3周年の振り返りとこれからの成長について）","contentSnippet":"概要Mackerel Dayに行ってきたのですが、用語とかがわからなくてイマイチ理解が進まなかったものなど、自分が分からなかったものを調べてみましたイベントレポートはこちらshitake4.hatenablog.com分からなかったことTwilioグラフアノテーションディザスタリカバリ対象セッションTitle Mackerelリリース3周年の振り返りとこれからの成長についてTime 14:10〜14:30Speaker   はてな 杉山 様1. Twilio調べてみた結果TwilioTwilioとは、様々な通信チャネルを連携するためのコミュニケーションAPIです。電話、SMSのほか、ビデオ、チャットなどの通信手段をアプリケーションに簡単に埋め込むことができます。 https://twilio.kddi-web.com/function/API経由で固定電話やブラウザなどと繋いで、通話やSMS送受信、ビデオやチャットによる通信ができるようです2. グラフアノテーション調べてみた結果サービスやロールに関係する様々な事象をグラフにアノテーション（注釈）として残すことができます。 アプリケーションのデプロイやバッチ処理実行、テレビCMなどのビジネスキャンペーンとの相関を考慮しながらリソース状況を把握できるので、より直感的な分析ができるようになります。 とても役に立つ機能ですので皆様もぜひ使ってみてください！https://mackerel.io/ja/blog/entry/weekly/201701273. ディザスタリカバリ調べてみた結果日本語に訳すと「災害復旧」となります。地震や津波などの天災や、テロ、不正侵入などによりシステムが壊滅的な状況になった際に復旧・修復すること、また、その災害に備えたシステムや体制を指します。引用：https://www.idcf.jp/words/dr.html","link":"https://blog.shitake4.tech/entry/2017/10/11/Mackerel_Day%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%81%9F%EF%BC%88Mackerel%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B93%E5%91%A8%E5%B9%B4?utm_source=feed","isoDate":"2017-10-11T01:55:13.000Z","dateMiliSeconds":1507686913000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"Mackerel Dayに行ってきました | イベントレポート","contentSnippet":"2017年10月5日開催のMackerel Dayに行ってきたので、イベントのレポートですイベント概要エンジニアをワクワクさせる「直感的サーバー監視サービス」 Mackerel（マカレル）の正式リリースから3周年を祝して Mackerel Day を開催します。Mackerelリリース3周年の振り返りとこれからの成長についてTime 14:10〜14:30Speaker   はてな 杉山 様slide選ばれる理由導入が簡単でわかりやすい開発スピード(毎週リリース)マルチクラウド日本語サポートおすすめ機能多彩なアラート通知チャットへのグラフ月通知SMSや電話加電で通知(Twilio)URL外形監視SSL証明書の有効期限カスタムヘッダ・メソッドAWSインテグレーション大規模環境との親和性任意の権限でユーザーをオーガニゼーションへマッピンググラフアノテーション直近の主要なリリースAzureインテグレーショングラフボード機能サービス内に任意のグラフを集めたページを作成可能（便利！！）システムプラットフォームの堅牢化ディザスタリカバリを想定スケーラビリティの確保DevOps Competency初認定リリース予定メトリックデータの粒度を維持しながら保持一分粒度を400日保持どういう方向で成長させていくのか世の中の流れ動的でかつ複雑化するインフラ環境クラウドサービスコンテナを始めとする仮想化技術Mackerelとしての使命エンジニアにとってエッジなサービスビジネスを加速化させるための仕組みであること監視するだけでなく動的で複雑なインフラをより簡単にわかりやすくする仕組みDevOpsライフサイクルの中核として効率化を促進shitake4.hatenablog.comアプリケーションエンジニアがMackerelで楽しく監視構成している事例Time 14:35〜14:55Speaker   DMM.com ラボ様slide    アプリケーションエンジニアがMackerelで楽しく監視構成している事例  from Keiko Nishioka 観点アプリケーションエンジニアから見た事例導入ストーリーDMM.makeでの事例オンプレミスからクラウドへ移行クラウド移行することに伴いエンジニアの責務が変化移行プロジェクトについて使用するサービスAWSアプリケーションは大きく分けて３つが移行対象担当は2人（専任ではない）監視どうするか？今までZabbixで監視し、アラートが着たら対応監視サービスを独自にホスティングは厳しいこれから(構想)AWSで一括管理を想定CloudWatchとLambda採用するための観点比較するに当たっての観点利便性Mackerelは簡単かつ柔軟に設定できた。メトリクス取るのが楽監視構成監視対象EC2,ALB,RDSアプリケーションのホスティング以外はマネージドサービスにお任せEC2各種メトリクスミドルウェア、アプリの死活監視Checking logその他AWSインテグレーションにお任せAnsibleでのエージェント設定狙った構成がサクッと入った楽気持ちいい監視設定の管理Jenkinsからmkr monitors push設定のJSONはGit管理各種メトリクス監視、URL外形監視WEB上で設定をお試しすること多しチャンネル設定は手設定サービス・通知レベル毎にチャンネル設定得られた価値楽な監視構成つまづくことがほぼなしエージェントの設定プラグインの利用日本語ドキュメント気づきリソースが余ってる通知時のグラフでパッと見てヤバさを把握できるアプリケーションエンジニアでも異常がわかるMonitors設定はオンプレベースで確認中まとめ必要充分な監視を行えているアプリケーションエンジニアでも扱える導入が楽で、運用が楽しいMackerel インフラ基盤 AWS 移行の舞台裏Time 15:00〜15:20Speaker   はてな 大野　様SlideAWS移行の流れMackerelのサービス名を分けて移行DB、アプリケーション、DNSと切り分けて移行完了※お客様から遠いところから移行なぜAWSへ移行？時系列データベースデータセンター運用コストの削減クラウドに移行して問題を解決したい！！時系列データベースの移行mackerel-agent, APIが送るメトリックを保存時系列データベースは自分たちで作り直した移行時にはデータをコピーしながら2拠点（aws,データセンター）に書き込んでいた時系列データベースの運用(Redis Cluster)想定していた状態Elasticacheで運用懸念点動的にスケールできないクラスター作成後のノードが追加削除できない実際の状態Redis ClusterをEC2上で動かしているRedis Cluster複数のレディスをシャードとして分割しているキーでシャードを分けているシャードが偏ることがある、つまり負荷が偏るシャードが偏るとどんなことが起きるのかCPU使用率がボトルネックになっているmaxmemoryにあたって書き込めなくなるメトリックはredisプラグインで収集しているDNSキャッシュサーバ社内の権威サーバーがデータセンタにあるデータセンタのサーバに問い合わせる構成拠点ごとに権威サーバはない社内ツールを使う為に依存しているUnboundメリットキャッシュを効率的にフラッシュできる他のキャッシュサーバの選択肢dnscacheフラッシュさせるには停止が必要dnsmasqすべてのレコードをフラッシュしてしまうunbound 運用VPC内のリゾルバはTTL60で固定されているMackerelホストのunboundはGoogle public DNSに問い合わせる.ioドメイン不調時にはすぐに気づいたMackerelもmackerel.ioにメトリックを投稿しているアクティブスタンバイ構成の実現DBはアクティブ、スタンバイkeeepaliveでmaster,backup構成keepalivedによるフェイルオーバAWSでのネットワークモニタリングDCではスイッチからメトリックを収集していたネットワーク安定性モニタリングSNMPプラグインTCPパケットの再送、再送パケットの割合が見れるAZ間の通信料モニタリングiptablesのチェインでみるvpcフローログでなくても見れるまとめAWS移行の見えない部分についてのお話AWS移行は様々な技術に支えられているAWSに移行したことでMackerel自体の監視、モニタリングも進化しているまだまだエージェントプラグイン便利にできるshitake4.hatenablog.com大丈夫！ Mackerel には CRE がいますTime 15:25〜15:55Speaker   はてな 井上 様slideCREとは?顧客信頼性エンジニアCREが在籍していることの意味Mackerelによって提供されているものサーバ監視が効率化されるという価値動的なインフラ管理を実現することでDevOpsが加速されるという価値→これらの価値はサービスが利用されることで生まれる価値価値を支えるものは？プロダクトそのものユーザーからの信頼技術力によって支えられている向上させる他の要因向上させる他の要因とは？投げかけた質問に対し的確な回答プラグインの導入法などに対してドキュメントがあること知らない人が短期間で把握できること上記３点を解決するのがCRECREは具体的に何をやっているのか？投げかけた質問に対し的確な回答寄せられた問い合わせにたして、出来る限り力になる技術的な課題には立ち向かいたくなるインフラエンジニア、SREという肩書は少数精鋭インフラ基盤の安定運用というミッションに対しても、その少人数のメンバーに大きな責任がのしかかっているという現状具体的な努力Mackerelとセットで使われることの多い技術・プロダクトについても日々理解を深めるミドルウエアの最新バージョンのコミットを追いかける社内勉強会輪読会価値を向上させるもの1 投げかけた質問に対し的確な回答成果（前期実績）同営業日中の返答率：90％〜翌営業日の返答率　99％やりとり（往復）の平均回数　2.0未満価値を向上させるもの2 プラグインの導入法などに対してドキュメントがあること公式Webヘルプがいつでも閲覧可能ヘルプドキュメントAPIドキュメント公式ブログドキュメントの管理方法公開されているドキュメントはGithubで管理公開までのフローをコマンドラインで公開可能価値を向上させるもの3 知らない人が短期間で把握できることハンズオンを開催直接説明に伺う魅力を伝える為にイベントに登壇freeeでMackerelを使って一年間サービスを運用してみた事例紹介Time 16:00〜16:20Speaker   freee 浅羽 様slide導入前の話Zabbixを使用VPC毎にzabbix serverを運用機能が豊富なので作り込めば色々なことが出来るしかし作り込みや運用に時間を取れない状況いくつかのプロダクトを評価した観点移行のしやすさプロダクトの進化スピード使いやすさコストAutoScalingとの親和性ZabbixからMackerelへ現在の監視構成MackerelNewRelicCloudWatchBugsnagDeep Security as a ServiceService, Role, Hostの考え方プロビジョニングやデプロイはEC2タグで処理を分けているので、タグの情報をそのままMackerelへ移植サービス開発エンジニアとのコミュニケーションダッシュボードかサービス一覧のグラフを眺める定期的にパフォーマンス振り返り会を実施ぽちぽち作るのは面倒なのでmkrコマンドで作るさらに深掘りしたい場合は、NewRelicで確認する何かあったときやグラフをシェアしたいときデプロイの記録を行ういつデプロイしたかわかるように記録サービスメトリックの使い所サービスに紐づくメトリックレスポンスタイム非同期ワーカーの未処理のキューサーバ台数サービスメトリックの放り込み方アラート通知基本的にはslackに通知WarningはSREが見るCriticalは広めに通知夜中のアラートPagerDutyなどは使わずに雑にbotが電話をかけていくslackに誰か反応したら電話を切るMackerelの設定Host Statusの初期状態はstandbyAutoScalingのUserDataが動いている間はアラート出したくないUserDataの中でmkrを叩いてworkingに戻す構築でコケた場合も実験的機能とりあえずonにしておくMackerelに欲しい機能毎月の支払い（レシート）をPDFで欲しいAWSインテグレーションも自動退役機能が欲しいEC2でないリソースを主にstaging環境で作ったり消したりするので、消すスクリプトを作ったタグ・除外タグをサービスごとに設定出来ると嬉しいまとめ全く問題なく運用できてます質問Zabbixの頃のほうがよかったことはあるか？特にない。Mackerelで出来ないものもあったが、そもそも監視する必要のないものだったりしたので、監視すべきことが整理出来たのが、よかったshitake4.hatenablog.comMackerelを導入して変わったN個のことTime 16:25〜16:55Speaker   GMOペパボ 高石 様slide使用状況サービス：20メンバー:100ロール:300ホスト：1000サービスメトリック:300外形監視：70Mackerelが使われるキッカケnagiosの管理が大変サーバーの追加、削除時に設定ファイルの更新が必要SERF&イベントハンドラでいちおう自動化は可能監視サーバーが複数あるどこをみればいいのかわからないクラウドらしい仕組みへの移行サーバーの管理を手で行っていたサーバーがボコボコ生まれ変わる時代だと厳しい監視設定の追加情報の一元管理サーバ自体とパッケージ情報も管理したいパッケージ更新したっけ？をなくしたい監視サーバーが複数あるのも同様の問題Mackerelに移行した結果どうなったか？nagiosの管理が大変nagiosの管理が不要クラウドらしい仕組みへの移行サーバーの管理が楽情報の一元管理Mackerelのページを見ればすべて載っているどのような使い方？サービスディスカバリとして使う何かをデプロイするときに、デプロイ先を知りたい退役忘れ、ロール設定忘れをチェックする退役忘れで無駄にライセンス消費ロール設定忘れて、運用に支障ロール毎のサーバー数を数えるconsul未所属サーバーの検知リリースタイムを計測したい改善したときにどの程度改善出来るのか知りたいステータスコード毎のリクエスト数を取得sideKiqのジョブ数監視ジョブが詰まって障害になっている時に気づきたい過去の特定時点でどの程度ジョブが溜まっているかみたいTreasureDataのジョブ数監視ジョブが詰まると他のジョブに影響することがあるエラーには気づけるが、その後リカバリ作業が必要ジョブ数を関しして、閾値を超えたらアラートしたいGHE(GitHub Enterprise)のディスク使用量監視ディスク利用量が突如異常な増加いまいち原因が分からないので監視したいお問い合わせ数を監視お問い合わせが急増していないか知りたいリリース後の思いがけないバグまとめやりたいことに集中できる１つのダッシュボードを見ればすべてわかるインフラ周りだけでなくいろんなものを気軽にモニタリングDriving Mercari with 50+ custom PluginsTime 17:00〜17:40Speaker   メルカリ長野 様slideメルカリ＆インフラストラクチャの紹介日本 さくらインターネット（石狩DC）アメリカ　(AWS, GCP)イギリス (GCP)Mackerel導入理由異なるインフラストラクチャの監視項目・内容を共通化する以前はregion毎にzabbixを利用。バージョンがずれたり監視内容の差が発生Service/Roleを利用することで管理サービスメトリクスの柔軟な使い勝手nagios互換のpluginMackerel以外の監視Kurado基本的なメトリクスはこちらで管理NewRelicアプリケーションのチューニングの参考Service/Role設計&デプロイサービスを行うregion毎にServiceを分ける外形監視は別Service通知チャンネルを分けるためQA環境・マイクロサービスRole設計Role名のPrefixに意味を持たせるrole-　サーバーの基本的な役割role-mysql, role-applicationなどz- 共通の役割多くのサーバーはz-commonに属するx- 監視上のフラグrole-mysqlはレプリケーション監視を行うが、x-mysql-masterを追加することで監視除外するROLEの自動付与サーバに付与するRoleをどこかで自動で設定したい#role-def:ロール名 を追加すると起動時に読み込み、agentの起動オプションとして利用Roleのprefixに意味を持たせる。conf内にRole名を書いて自動で設定confはansibleで配布監視にまつわる数字監視ルール数: 265Host毎の監視ルール数Mysql 34Application 39Search 36カスタムプラグイン +50カスタムプラグインz-commonscheck_resolverresolv.confを独自に読み込んで名前解決するdiff-detectorコマンド結果の変化があるとアラート'cat /etc/passwd', 'uname -a', 'hostname' を見ているcheck-iptablesさくらの専用サーバはすべてglobal ipを持つ。不要なサーバはdisableにして運用不用意な iptables --list　でiptables_filterが読み込まれ、パフォーマンスに影響するのを発見check-uptime不意な再起動を検知閾値は2分-10秒。1回アラートが来てすぐに復旧するMysqlやmemcachedでも行っているcheck-inodeinode 枯渇防止check-machine-exceptionsメモリ異常を検知した際のログを監視check-raid-disk(MegaRAID)MegaCLIを使い各物理Diskの状態を監視mackerel-plugin-ntpqOffsetとリモートとのSync状況の可視化mackerel-plugin-linux-lite2Coreから56Coreまでサーバがある一貫した監視閾値を設けやすいように可視化z-commons以外のpluginperiodic-checker特定の時間のみ監視を行うcheck-dns-rrcheck-spf-and-reserve-lookupメール配信にて利用サーバが持っているGlobalIPすべて確認chech-mysql-slave-sql-errorレプリケーションが止まった時に、その理由も通知してくれると便利で作ったPlugins便利で作ったPluginscheck-mysql-msrMySQLのMulti Source Replicationの監視mackerel-plugin-msrcheck-msyql-msrの可視化その他の取り組み問い合わせ数の監視多くの人が参加するChannelへ通知障害の検知、影響範囲の把握監視されていないサーバの自動抽出slackへの通知1日2回slackへ通知監視されていないサーバstandby,poweroffのサーバまとめコードを書いて問題を解決するMackerelは使い勝手のいい監視ツールAWS Ecosystem with MackerelTime 17:45〜18:15Speaker 酒徳 様DevOps関連サービスソースコードのバージョン管理CodeCommitビルド自動化CodeBuildデプロイ自動化CodeDeployCloudFormationElasticBeanstalkワークフロー管理CodePipelineCloundFormationInfrastructure as a codeAWSリソースの環境構築を自動化ChangeSet SupportStackSet SupportSecurityユーザ/クレデンシャル管理アクセス権限管理権限の委任と監査イベント行ってみての所感これからMackerel使いこなしていきたいなと考えてのイベント参加だったので、使うのが楽という発表を聞いて色々と触ってみたりしたいという欲求が更に高まりました読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/10/05/%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88%EF%BC%9AMackerel_Day_2017/10/5?utm_source=feed","isoDate":"2017-10-05T11:08:52.000Z","dateMiliSeconds":1507201732000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"辛くなってきたら始めてみたい個人タスクの管理","contentSnippet":"毎日大量にメールが送られてきて、自分がやらなくてはいけないタスクが書かれたメールを見落としたり、タスク管理ツールをうまく使いこなせなかったりしている人に是非試してもらいたいTipsやりかたやり方は非常にシンプルタスク管理ツールやメールを以下のカテゴリに分けるだけ！今日やることやることやったほうがいいこと人にお願いしたこと人にお願いすること※該当しないものなどは特にカテゴリ分けしない運用方法出社して一番先にタスク管理ツールのやること、やったほうがいいことの順番で確認今日やることに上げられそうなものを確認し、タスク管理ツールの今日やることにカテゴリを変更するメーラーのやること、やったほうがいいことの順番で確認今日やることに上げられそうなものを確認し、タスク管理ツールの今日やることにタスクを追記する今日やることのリストにあるタスクをひたすらやる帰社するタイミングで今日やることが残っていたら、またカテゴリを振り直す運用してみて半年くらいやってみてますが、今のところタスクのヌケ、モレは出ていないという感じです。もっとタスクの数が増えてきたりして破綻しそうだったらまた考えてみようかなと思ってますタスクツールで期限とか設定しておけば、リマインドもしてくれるので、つい忘れたとかも今のところはなさそうです僕が使っているツールWunderlistシンプルな機能と使い方によって柔軟に運用できそうだったので、好んで使ってますGamilラベルにカテゴリを作成して分類してます読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/10/04/%E8%BE%9B%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%8D%E3%81%9F%E3%82%89%E5%A7%8B%E3%82%81%E3%81%A6%E3%81%BF%E3%81%9F%E3%81%84%E5%80%8B%E4%BA%BA%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E7%AE%A1%E7%90%86?utm_source=feed","isoDate":"2017-10-04T08:32:14.000Z","dateMiliSeconds":1507105934000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"ソースコードのコメントで見るTODO、FIXMEって何？","contentSnippet":"開発現場で見かける TODO や FIXME のコメント。些細な備忘録のように思われがちですが、実はチーム開発における文脈共有や技術的負債の可視化に欠かせない重要な存在です。アノテーションコメントとは？各種アノテーションの意味と使い分けRubyでの活用方法アノテーションコメントのベストプラクティスチーム運用の工夫参考文献アノテーションコメントとは？ソースコードに記載する特定目的のコメントをアノテーションコメントと呼び、以下のように記載します。# TODO: 実装内容を具体的に記述主な目的は以下のとおりです。タスクの明示コード改善点の記録注意喚起や保守性の向上開発の現場では、こうしたコメントが「技術的負債」の兆候となるだけでなく、文脈の共有やコードレビューの効率化にも貢献します。各種アノテーションの意味と使い分けそれぞれのアノテーションには明確な意味と用途があります。以下に主な例を紹介します。キーワード内容補足TODOあとで追加すべき内容を表す要実装の仕様やタスクの先送りに使われるFIXME修正すべき箇所を表す動作不具合や設計上の懸念に関する緊急度の高い示唆OPTIMEZEパフォーマンスの最適化をすべき箇所を表す処理負荷やリファクタの余地がある場合に使うHACKリファクタリングすべき箇所を表す暫定対応やワークアラウンドの記録としてREVIEWレビューすべき箇所を記す他者確認を必要とする設計・仕様の判断点にRubyでの活用方法Railsではアノテーションコメントを一括で確認するコマンドが用意されています。Railsでない場合は、rake-notes: rake notes task for non-Rails projects で出力することも可能です。全アノテーションの一覧表示bin/rails notes特定アノテーションの絞り込みbin/rails notes --annotations FIXME独自アノテーションの追加も可能config.annotations.register_tags(\"DEPRECATEME\", \"TESTME\")アノテーションコメントのベストプラクティス質の高いTODOコメントは、後の作業者にとって貴重な手がかりになります。以下を意識するとより有用なコメントになります。簡潔かつ具体的に書くチケット番号やIssueリンクを明記完了条件を記述する担当者名を入れて明示的にたとえば、以下のように記載します。# TODO: 画像アップロードのバリデーションを追加  # TODO: 画像アップロード時にフォーマットチェックを追加 [#56]質の高いTODOコメントは、後の作業者にとって貴重な手がかりになります。以下は避けたい例です。# TODO: 後でやるチーム運用の工夫チームで活用するには、以下のような仕組みが効果的です。ルールの明文化README.md や CONTRIBUTING.md に、使用可能なアノテーション一覧と記述ルールを記載例: # TODO: 実装内容（関連Issue: #123）CI/CDと連携したチェックbin/rails notes をCIで実行し、FIXME や HACK の存在を検出メトリクスとして可視化notes件数をグラフ化し、技術的負債の増減をレビューで議論例：bin/rails notes | wc -l参考文献The Rails Command Line — Ruby on Rails GuidesTODO comments best practices – Gilles Leblanc's blogruby-style-guideRails | コード内のコメントを見つける方法 (TODO、FIXME、OPTIMIZE、HACK、REVIEW)Taming TODO and FIXME comments. Software developers use TODO and FIXME… | by Thomas Junghans | Mediumrubysoftwareconservancy/rake-notes: rake notes task for non-Rails projects","link":"https://blog.shitake4.tech/entry/2017/10/03/%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%A7%E8%A6%8B%E3%82%8BTODO%E3%81%A3%E3%81%A6%E4%BD%95%EF%BC%9F?utm_source=feed","isoDate":"2017-10-03T08:55:04.000Z","dateMiliSeconds":1507020904000,"authorName":"しいたけ@shitake4","authorId":"shitake4"},{"title":"RspecでStrongParamtersを使ってハマった","contentSnippet":"rspecでStrongParamtersを利用したテストを書いた時にはまったので、備忘録として書いてみるStrongParamtersとは？4.5 Strong Parametersstrong parametersを使用することで、Action ControllerのパラメータがActive Modelのマスアサインメントに利用されることを禁止できます。ホワイトリストに追記したもののみ使用できます。これは、多くの属性を一度に更新したいときに、どの属性の更新を許可し、どの属性の更新を禁止するかを明示的に決定しなければならないことを意味します。大雑把にすべての属性の更新をまとめて許可してしまうと、外部に公開する必要のない属性まで誤って公開されてしまう可能性が生じますので、そのような事態を防ぐために行います。（Railsガイド）https://railsguides.jp/action_controller_overview.html渡ってきたパラメータのホワイトリストを用意し、ホワイトリストの項目が存在しない場合にエラーとして処理することができるもの今回ダメだった書き方Rspec 3.1.0 使用Rails 4.1.8 使用let(:params) { { first_name: '佐藤', last_name: '太郎'} }正しい書き方単純でHashに対してStrongParametersを書くのではなく、ActionController::ParametersでNewする必要があった    let(:input) { ActionController::Parameters.new(user: params) }    let(:params) { { first_name: '佐藤', last_name: '太郎'} }     読者です        読者をやめる                    読者になる        読者になる","link":"https://blog.shitake4.tech/entry/2017/10/02/Rspec%E3%81%A7StrongParamters%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%8F%E3%83%9E%E3%81%A3%E3%81%9F?utm_source=feed","isoDate":"2017-10-02T08:48:48.000Z","dateMiliSeconds":1506934128000,"authorName":"しいたけ@shitake4","authorId":"shitake4"}]
